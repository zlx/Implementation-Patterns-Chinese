## 第5章  类

类的出现要追溯到柏拉图时代。柏拉图式的固体是一种类型，世界上可见的一种形式。柏拉图式球体更加贴切但它不够坚固。我们身边到处可以碰到的球形，它们有时候并不完美。

面向对象编程以一种后西方哲学式的方法捡起了这种概念，将程序划分为类。类描述了一堆相似东西的通用特征，而对象就是这些东西。

类在交流时很重要，因为他们潜在地描述了许多特定的东西。类层次的模式拥有实现模式中最长的持续时间。相比之下，设计模式，主要在探讨类之间的关系。

这章节中出现的模式：

+ 类				-----  使用一个类是指：它包含了一些数据和一些逻辑
+ 简化父类名		-----  用一个简单的名字命名类继承结构的根
+ 差异化子类名	-----  命名子类时要突出与父类之间的联系和差异
+ 抽象接口		-----  从实现中分离出接口
+ 接口			-----  特指不经常变化的抽象接口
+ 接口版本化		-----  安全地扩展接口
+ 抽象类			-----  特指某一个可能会被抽象类导致变化的抽象接口
+ 值对象			-----  一个就像数字一样与状态无关的对象
+ 特质化			-----  清晰地表明关联计算中的相似点和不同点
+ 子类			-----  表示普通的子类
+ 实现			-----  用一个方法类包含一系列计算
+ 内部类			-----  在私有类内部打包一些有用的代码
+ 特定对象行为	-----  特定实例的逻辑
+ 附加条件		-----  明确的条件的逻辑
+ 代理			-----  把一系列逻辑代理到某个对象
+ 可插拔选择器	-----  仔细执行一个方法的一系列逻辑
+ 匿名内部类		-----  在方法中覆盖某几个其它方法的一系列逻辑
+ 库类			-----  保存一系列不属于任何对象的静态方法

### 类

数据比逻辑容易改变。正因为如此，类才有用。每个类都在宣告：逻辑被有序组织，比其操作的数据更稳定，而数据被其相关的逻辑用于操作并发生改变。但是，数据会发生改变，逻辑不会变，这件事也不是绝对的。有时候不同的数据值导致逻辑不太一样，有时候不同的条件也会导致逻辑很不相同。而有时候在一个计算进程里面数据不会发生变化。 学习如何将逻辑打包成一个类和区分逻辑中容易变化的部分是进行有效的对象编程的一部分。

将类合理组织是某种形式上的压缩，抽离出父类并在用于子类。向所有压缩技术一样，这导致代码异常难读。你必须理解父类，才能明白子类干了什么。

谨慎地使用继承是进行有效编程的另一方面。创建一个之类就表示：我和父类很像，但是也有不一样。（还记得覆写父类的方法吗？如果我们每次都慎重的选择隐喻，我们会更加擅长编程。）

类比对象的代价要昂贵得多。一个类应该做一些重要的事情。减少我们系统中的类是一种进步，就像我们要避免类变得臃肿一样。

以下的模式解释了我们如何和清晰的类交流。   