## 第5章  类

类的出现要追溯到柏拉图时代。柏拉图式的固体是一种类型，世界上可见的一种形式。柏拉图式球体更加贴切但它不够坚固。我们身边到处可以碰到的球形，它们有时候并不完美。

面向对象编程以一种后西方哲学式的方法捡起了这种概念，将程序划分为类。类描述了一堆相似东西的通用特征，而对象就是这些东西。

类在交流时很重要，因为他们潜在地描述了许多特定的东西。类层次的模式拥有实现模式中最长的持续时间。相比之下，设计模式，主要在探讨类之间的关系。

这章节中出现的模式：

+ 类				-----  使用一个类是指：它包含了一些数据和一些逻辑
+ 简化父类名		-----  用一个简单的名字命名类继承结构的根
+ 合理化子类名	-----  命名子类时要突出与父类之间的联系和差异
+ 抽象接口		-----  从实现中分离出接口
+ 接口			-----  特指不经常变化的抽象接口
+ 接口版本化		-----  安全地扩展接口
+ 抽象类			-----  特指某一个可能会被抽象类导致变化的抽象接口
+ 值对象			-----  一个就像数字一样与状态无关的对象
+ 特质化			-----  清晰地表明关联计算中的相似点和不同点
+ 子类			-----  表示普通的子类
+ 实现			-----  用一个方法类包含一系列计算
+ 内部类			-----  在私有类内部打包一些有用的代码
+ 特定对象行为	-----  特定实例的逻辑
+ 附加条件		-----  明确的条件的逻辑
+ 代理			-----  把一系列逻辑代理到某个对象
+ 可插拔选择器	-----  仔细执行一个方法的一系列逻辑
+ 匿名内部类		-----  在方法中覆盖某几个其它方法的一系列逻辑
+ 库类			-----  保存一系列不属于任何对象的静态方法

### 类

数据比逻辑容易改变。正因为如此，类才有用。每个类都在宣告：逻辑被有序组织，比其操作的数据更稳定，而数据被其相关的逻辑用于操作并发生改变。但是，数据会发生改变，逻辑不会变，这件事也不是绝对的。有时候不同的数据值导致逻辑不太一样，有时候不同的条件也会导致逻辑很不相同。而有时候在一个计算进程里面数据不会发生变化。 学习如何将逻辑打包成一个类和区分逻辑中容易变化的部分是进行有效的对象编程的一部分。

将类合理组织是某种形式上的压缩，抽离出父类并在用于子类。向所有压缩技术一样，这导致代码异常难读。你必须理解父类，才能明白子类干了什么。

谨慎地使用继承是进行有效编程的另一方面。创建一个之类就表示：我和父类很像，但是也有不一样。（还记得覆写父类的方法吗？如果我们每次都慎重的选择隐喻，我们会更加擅长编程。）

类比对象的代价要昂贵得多。一个类应该做一些重要的事情。减少我们系统中的类是一种进步，就像我们要避免类变得臃肿一样。

以下的模式解释了我们如何和清晰的类交流。

### 简化父类名

找寻合适的名字是编程过程中最让人满足的时刻。你要和一个个观点作斗争。久而久之，代码就变得异常复杂，尽管它可以变得更好。然后，我们经常听到有人说：“对，这已经（修改名字）在计划当中”。恰当的名字可以帮助之后的简化和改进。

而最最重要的是挑选类名。类是程序设计里面的最关键部分。一旦类名确定了，他的操作名字也确定了。反过来的情况却很罕见，除非刚开始类名就被随意确定。

给类命名时通常会纠结于保持简洁还是含义丰富。比如说可能会有如下关于类名的对话：“你在换算前记得转换了吗？”这时候，名字应该是简洁有力的。然后，有时候为了让名字清晰，我们需要好几个单词来表达。

走出这种困境的做法是使用一些计算领域的隐喻。使用隐喻，即使是一个简单的单词也会带来丰富的含义。比如说，在一个叫 HotDraw 的画图框架里面，我给画图用的一个对象取的第一个名字是 DrawingObject。沃德· 库宁汉姆 总是意味着排版的创始人：画图就像打印一样，也是如何排列页面。页面上的绘画元素都是图形，所以这个类可以叫做 Figure 。使用了隐喻， Figure 比 DrawingObject 更简短，含义更加丰富也更加明确。

有时候，好名字需要花时间。你可能已经写完了代码，甚至过去了好几个礼拜，好几个月，甚至于好几年，突然，你找到一个更好的名字。有时候，你很难确定用哪一个名字：翻遍同义词典，写下来一堆看上去都合适的名字。有时候，你需要忘记它们的功能，相信时间，你的潜意识会帮你选一个好名字。

交流一直是一个找到一个好名字的好办法。对别人解释这个对象的目标和作用可以让我获得更多的理解和想象。这些想象可能导致我找到一个新名字。

给每个重要的类找一个单个单词的名字。

### 合理化子类名

之类的名字有两个功能。它们需要表达它（该子类）像谁并且（与父类比）有什么不同。同样的，它们也需要均衡简洁和含义。不像父类，之类名不会经常在对话中使用，所以它不需要为了简洁牺牲含义。可以在父类名上面添加一些修饰语来命名子类。

一个例外情况是，如果子类是严格地用来实现某种机制并且在其中有扮演了一个重要的角色。这时候，需要给子类一个像父类一样简洁的名字。比如说：HotDraw 有一个类叫 Handle 用来完成特定图形的绘制工作。所以，尽管它扩展了 Figure，它也有一个简洁的名字 Handle。 Handle 有一个完整的继承体系，他们大多数被命名为 StretchyHandle TransparencyHandle 等等。因为 Handle 是他自己的继承体系的根结点，他作为一个简单的父类，而不是合理的子类。

另外一个关于子类命名的麻烦是多继承。多继承体系经常在代理时出现，但是它们同样需要一个好名字。这时候，你要尝试从读者的角度考虑，而不是单纯地在父类名上面附加修饰语。想象别人希望知道这个类更像那个类，用这个父类名作为基本元素。

和别人交流是类名的最终目的。如果考虑到计算机，类名只需要方便计数即可。太长的名字不容易读写。类名应该尽可能地减少占用读者的短期记忆。孤立的类不容易理解和记忆。用类名来讲述你的代码故事。

### 抽象接口

古老的寓言说，我们要对接口编程，而不是实现。另外一个说法是：尽可能地隐藏设计决策。如果我的大多数代码都仅知道我在处理一个集合，那我就能比较自由地修改类的实现。然后，有时候，你不得不将你的混乱的类提交出去，以便计算机能够工作。

这里所说的“接口”，是指一系列没有实现的操作。他对于 Java 来说可以是一个接口，也可以是一个父类。接下来的模式将会介绍那种形式更合适。

每一层接口都有代价。他增加了学习，理解，文档维护，调试，组织，浏览和命名的成本。尽可能多地使用接口并不会使软件成本最低。只在你需要灵活性的地方使用接口。因为你有时候不能提前哪里需要接口来减少开支，可以尝试在需要灵活性的地方推测接口是否合适。

多数时候，我们抱怨一个软件不够灵活，我们有一堆方法可以让它变得更灵活。从最基本的比如每个 integer 型的占用空间大小到新的业务模型，大多数软件不需要做到极致（灵活）。

另外一个使用接口的好处是软件的不可预测性。软件工业上似乎信奉一个观念：如果我们的软件设计得足够好，那就不需要改变。我最近看到了导致软件改变的一些理由。其中包括程序员没根据需求实现，客户改变了主意等等。其中漏掉了很重要的一点：和你变更。它假定所有变更都是不应该存在的。为什么每天都要天气预报？因为天气是不可预测的。那为什么系统需要保持灵活？因为需求和技术都是不好预测的。即使客户马上就要了，我们也不能降低开发好一个系统的要求，但是我们可以适当的限制对未来系统的猜测。

总的来说，灵活性的需求，灵活性的代价，灵活性的不确定性作为我们选择使用使用灵活性的依据。介绍灵活性的代价是因为你需要在现有系统上修改代码。如果你漏掉了某处需要修改的地方，那未来就存在风险，开发框架那一章重点说明个这个话题。

Java 里面的两种机制：抽象街口，父类和接口有不一样的代价。

### 接口

一种说法：“这就是我需要实现的目标，其它的细节我不关心”就是描述了一个 Java 中的接口。接口是 Java 中最早引入的一个重要方法。接口是一个很好的平衡。它拥有多继承的灵活性，却又避免了复杂性和歧义。一个类可以声明其实现了多个接口。接口只暴露操作，而没有属性，所以它能够在接口发生改变时有效地保护使用者。

因为接口改变需要对所有的实现改变，它就会对自身的改变更慎重。任何对接口的增加或者修改都需要修改所有的实现。如果你不能够修改实现，接口通常会标明修改并在未来的版本中改变。

接口不利于交流的一点是他需要所有的操作是公开的（Public）。我通常更希望它们是包可见的。如果自己使用，那接口都是公开也没关系，但是如果有很大的用户群，那最好是保持谨慎，这样能在未来需要变更时更方便。

有两种接口命名的方法，取决于你怎么考虑这个接口。还没有实现的类似于类的接口可以用类的方式命名（简化父类，合理化子类）。这样的方式的一个问题是你可能在给类命名时就将好名字用掉了。一个 File 的接口的实现可能只能命名为 ActuralFile， ConcreteFile 或者 FileImpl（既包含了后缀，又是简写）。一般情况下，说明清楚一个东西是一个具体对象还是抽象对象是很重要的，说明一个抽象对象是实现了一个接口还是继承了一个父类是相对不这么关心的。这种命名方式能够很好地体现接口和父类的差异，也能够在需要的时候及时改变。

有时候，简单地命名一个实际类比一个隐藏接口的沟通性更重要。这种情况下，在接口前面加个 “I”更好。比如接口叫 “IFile”， 类名就可以简单地叫做 File。

### 抽象类

在 Java 里面，另外一个抽象接口和和具体实现的区别是使用父类。这种情况下，父类是抽象的，并且不管它是不是抽象的，在运行时都可以被任何子类代替。

而为什么我们要使用抽象类，而不是接口，主要是两个原因：接口会发生变化或者需要实现多个接口。抽象接口需要支持两种变化：实现发生变化和接口本身发生变化。 Java 里面的接口对否后者的支持很弱。每次接口发生改变都需要改变所有实现。对于一些被广泛使用的接口，这很容易导致原有设计彻底瘫痪，唯一的解决方案就是对接口进行升级并在以后的版本里面修改。

抽象类则没有这种限制。只要指定默认实现，就可以在不扰乱既有实现的基础上添加新特性。

抽象类的一个限制是它的实现者只能使用他作为唯一的父类，如果需要其它的类，那他们必须以接口的形式实现。

在一个类上使用 Abstract 可以告诉读者，他们要使用这个类的话必须实现一些东西。最好的情况是让继承树的根类成为一个抽象类。一旦走上抽象化这条路，很容易就过度抽象。尽量让根类实例化可以帮助消除抽象你排除抽象来尽力做好自己。

接口和类继承不总是相对的。你可以用接口来表达：“这里说明了如何使用这些功能”，而一个父类这代表了：“这是该功能的一种实现”。所以，接口里面的变量需要注明类型，这样在需要的时候就可以重新实现。


### 版本化接口

当你想改变接口，但是又不能改的时候，你会怎么办呢？比如说，你想添加一种操作。因为添加操作会让所有已有的实现瓦解，所以你不能这么做。但是，你可以创建一个新的接口，然后扩展原来的接口，并在里面添加新操作。需要新操作的用户就使用新接口，而老用户依然使用旧接口。每次当你需要调用新操作，你都需要检查类型，并向下转型到新类型。

举个例子：

	interface Command {
	  void run();
	}

一旦这个接口已经发布，并且被许多人使用，修改他就会变得很麻烦。然后，需要添加一个 undo 操作。新版本的接口就要像这样：

	interface ReversibleCommand extends Command {
	  void undo();
	}	
	
原有的接口依然可以工作， ReversibleCommand 接口也可以代替 Command 接口，如果要使用新接口，

	...
	Command recent = ...
	if recent instanceof ReversibleCommand) {
	  ReversibleCommand downcasted = (ReversibleCommand) recent;
	  downcasted.undo();
	}
	...
	
使用 instanceof 减少了代码的灵活性。但是，这也是合理的，因为他实现了接口的升级。如果你有许多这样的接口，那客户端就需要许多额外的工作来处理这些差异。这就是需要重新思考设计的时候了。

可选接口是对一个糟糕问题的糟糕解决方案。接口并不能像他的实现一样易于修改。接口其实经常变化，就像我们做的设计一样。我们从实现和维护中的经验中学习设计。可选的接口创造了一种新的编程语言，它像 Java ，但是又有自己的新规则。编写新语言和编写应用程序是完全不一样的。所以，如果你也需要扩展接口，现在知道了怎么做了。


### 值对象

当需要计算的时候可以考虑使用有状态变化的对象，另外也可以考虑另外一种对象。数学已经有一千多年的历史了，它简化了现实世界的真理和必然性。

我们的编程语言包含了两种类型。一种就是 Java 里面的原始对象，对应于数学世界。当我们在 Java 里面给一个数加 1 时，我们声明一个数学运算（我们是想做一个计数，直到 2^32 或者 2^64）。我并没有改变一个对象，只是创建了一个新的对象。和大多数对象不同，你不能改变 0 本身。

这种功能上的计算并不改变任何状态，它仅仅创建新对象。如果某些情况下，你需要做一个声明或者问个问题，那这种功能性的类型就很恰当。如果情况随着时间会发生改变，那状态就比较合适了。有些情况，两种方式都可以考虑，那你如何选择使用那种类型（的对象）呢？

比如说：你可以认为一个图片是状态相关的，比如位图里面的像素。但是，你也可以认为一个图片是不变的。

[Figure 5.1]()

如何表达更有效取决于个人的偏爱，但是有时候也依赖于图片绘制的复杂度和是否经常变化。

程序接口比功能接口更普遍。程序接口的一个问题是程序调用子句是该类接口的一个重要组成部分。修改这样的程序是比较困难的，因为一个简单的修改可能导致未预期的问题。

数学之美在于它们很少有这种额外的影响。你可以创造一个绝对的，没有状态的世界。尽可能地创造数学微型世界。通过一个对象修改状态来管理它们。

比如说：使用不变的值作为基础交易来实现一个账户系统。

[Figure 5.2]()

	class Transaction {
	  int value;
	  Transaction(int value, Account credit, Account debit) {
	    this.value = value;
	    credit.addCredit(this);
	    debit.addDebit(this);
	  }
	  int getValue() {
	    return value;
	  }
	}     

一旦创建出来，就没有办法可以修改 Transaction 里面的值。更重要的是，这个构造器会声明所有交易在两个账号间进行。当我看到这个代码，我知道我不需要担心交易会流失或者交易的值会中途被改变。

要实现一个值对象（就是像 integers 而不是需要维护状态的对象），就要分清楚状态世界和值的世界的边界。在上面的例子中，一个 Transaction 是一个值，一个 Account 是一个可以保存状态的对象。在一个值对象的构造器中设置所有状态，并且不提供其它可以赋值的方式。对值对象的操作总是返回一个新对象。这些对象必须由调用着来存储。

	bounds.translateBy(10, 20);  // mutable Rectangle
	bounds = bounds.translateBy(10, 20); // value-style Rectangle
	
值对象的最大争议是性能。创建这些临时对象给内存管理系统添加了很大的压力。在程序的总成本中，这个问题并不总是被提起，因为大部分程序的瓶颈不在这里。另外，如果你不熟悉值对象或者很难区分可变对象和不可变对象的边界，请慎重使用。大多数值类型的对象在真实世界中是不可想象的，因为接口变得复杂并且你不能真正假定它（对象）不会发生变化。

到目前为止，我感觉编程除了三种最重要的类型--对象，方法和程序以及如何将他们有效组织以外，还有许多东西值得介绍。对于本书的目标来说，作为结束，我再次强调，有时候，你的程序最好混合使用有状态变化的对象和值对象。

### 专业化

表达出计算中的相似性和差异性之间的相互影响能够让你的程序更具可读性，可用性和易于修改。实践中，没有程序是独一无二的。很多相似的理念，通常是相同程序里面的多个地方用到了相似的理念。清晰地表达出相似性和差异性能够让读者更好地理解代码，发现它们的意图是否已经满足，即使没有，如何能够快速利用现有代码来满足他们的需求或者重写代码。

最简单的差异性就是那些状态的差异。比如：“abc” 和 “def”的不同。操作这两个字符串的算法是相同的。比如说，字符串的长度的计算方法是一样的。

最复杂的差异是在于逻辑的不同。字符表达式和数字排版几乎没有逻辑上的共同点，即使它们可能共享同样的输入。

在这两种极端情况之间--相同的逻辑和不同的数据以及不同的逻辑和相同的数据--在编程中有许多共同点。数据大多数情况下是相同的，除了少数。逻辑也是一样。（我猜测字符表达式规则和数字排版规则共享了一点点代码。）甚至于数据和逻辑的界限都很模糊。一个布尔型的数据影响了控制流程。一个帮助对象存储在一个属性里面以用于计算。

接下来的模型主要是帮助你处理逻辑上的这种相似性和差异性的。数据的多样性并不意味着过于复杂或精细。有效地处理逻辑上的相似性和差异性可以看出代码的膨胀。

### 子类

声明子类就是说：“这些对象像那些，除了...”，如果你有恰当的父类，创建之类将是一个很有用的方法。重写合适的方法可以让你用极少的代码复用现有的计算。

当对象刚刚开始普及的时候，子类被看作是银弹。首先，子类被用来划分类别--一个 Train 是 Vehicle 的子类，不管它们是不是共享了一些实现。及时的，有些人发现继承实际上是共享了一些实现，它可以最大限度地共享相同的部分实现。但是，很快，子类化的限制也开始凸显出来。首先，他只能用一次，在你调整它的结构之前，你需要了解现有的代码。其次，你还需要了解它的父类做了什么。当父类变得复杂时，这个限制就变得更大了。第三，父类的修改很困难，因为子类可能依赖了父类的某些特性。最后，当继承树很深的时候，这所有的问题就层层叠在一起，导致了更大的问题。

一种特别糟糕的继承的应用是创建分布继承体系，就是那种这个继承体系里面的每个子类都需要另外一个体系内的子类。这是某种形式上的重复，创建了类继承的之间的伴侣类。当我经常看到分布继承体系时，我很难想象如何去改进设计。

[Figure 5.3]() 

一个典型的例子是保险系统，如 Figure 5.3 所示。图片中有些东西是错的，因为 InsureanceContract 不能指向 PensionProduct 并且不能很好的将产品的属性移到子类中去。一个尽管我们永远做不到，但是可以尽量接近的解决方案是将多样性分解，来让 Contract 不管是和 Insurance 还是 Pension 一起都保持一致。这就需要创建一个新对象来表示这种现金流程。

[Figure 5.4]()

如果你考虑了这些注意点，那子类化是一个非常强大的工具来表示计算中的相似差异性。合适的子类能帮助很多人用一两个方法就可以精确表达。要想真正使用好子类就要彻底地将一件事的逻辑封装在父类的方法中。当实现一个子类时，你要完全重写一个方法。如果父类方法很大，那就拷贝并且修改它。

[Figure 5.5]()

拷贝代码说明了两个类之间存在隐含了类似。你很难在没有检查和修改所有潜在的地方的前提下在父类里面完成修改。

我设计的目标是能够在不同的策略之间随意切换，根据目前代码的需要。使用条件，子类或者代理来使代码更形象化。那是不是意味着其它策略比你现在使用的有优势呢？在那个方向上做一些尝试然后看看是否有所提升。

子类的最后一个限制是它不能表达一个正在改变的逻辑。你必须要在创建对象之前知道可能的变化，不然之后就不能变化。你必须要使用条件表达式或者代理来表示逻辑的改变。

### 实现器

在一个基于对象的程序中，多态是一种基础地表示选择的方式。当某个信息可以进行选择时，它就需要有多个可以消费消息的对象。

已经被无数次地证明了，不管使用 Java 的接口和 implements 声明还是表达 extends 的子类，都说明了：从计算的某个方面来说，只要符合代码的意图，细节并不重要。

多态消息的一个优美之处是于它们开启了一个多样性的系统。如果程序的一部分需要给另一个系统写一些字节，一个抽象的 Sockets 就实现了 socket，而不需要关心具体调用细节。和表达相同意图的程序相比，它详细而完备的逻辑，使得这些对象/消息模型是清晰的，意图（写一些字节）和实现（调用 TCP/IP 协议）相分离。同时，像对象和消息一样来表达计算使得其可以在原有基础上处理未来不可见的变化。这种表达的清晰和程序的动态的结合就是基于对象的程序语言占据编程语言优势的原因。

但是这种优势在用 Java 写程序时经常会被随意挥霍。这个模式是帮助你来清晰而又易扩展地表达逻辑。

### 内部类

有时候你想封装某些计算逻辑，但是又不想为它额外创建一个文件或者新类。声明一个小的私有类（内部类）允许你以较低的成本获得类的好处。

有时候，内部类仅仅继承自 Object 。有时候，内部类也扩展了其它父类，那些仅有内部感兴趣的特性。

内部类的一个特性是当创建了一个实例，它们就获得了一个创建了这个它们的对象的一份拷贝。这样就可以方便地和封装好的数据进行交互，而不需要建立额外的联系：

	public class InnerClassExample {
	  private String field;
	  
	  public class Inner {
	  	public String example() {
	  		reurn field;  // Uses the field from the enclosing instance
	  	}
	  
	  @Test public void passes() {
	  	field = "abc";
	  	Inner bar = new Inner();
	  	assertEquals("abc", bar.example());
	  }
	 }

然后，在上面的内部类中，即使你声明了，也没有真正的无参构造器。当你使用反射创建内部类的实例时，就有一个问题：

	public class InnerClassExample {
		public class Inner {
			public Inner() {
		}
		@Test(expected=NoSuchMethodException.class)
		public void innerHasNoArgConstructor() throws Exception {
			Inner.class.getConstructor(new Class[0]);
		}
	}
	
如果想真正地和封装它的实例中分开，就声明为 static 。


### 实例特有的行为

理论上，一个类的所有实例共享相同的逻辑。突破这个限制就产生了一种新的表达方式。这种类型都有一个代价。如果一个对象的逻辑都有它的类持有，那读者就可以通过代码知道逻辑。一旦你的某些实例有不同的行为。你必须在运行环境下或者分析数据流才能了解一个特定的对象到底如何表现。

另外一个实例行为的代价是，当计算过程中逻辑改变了的时候。对于那些一旦创建就不改变的对象，设置实例行为是比较合理的做法。


### 条件表达式

If/then 和 switch 是最简单的实例特有的行为。使用条件表达式，根据数据的不同，不同的对象会执行不同的逻辑。条件表达式作为一种表达方式，它（与一般的实例特有的行为相比）具有在类中可见的优势。读者不需要到处寻找计算路径。然而，条件表达式的缺点是除非修改错误对象的代码，否则它就不能修改。

通过程序执行的每条路径都有一定可能是正确的。假定每条路径正确的几率是相互独立的，那可能的路径越多，程序正确的可能性就越小。虽然这个几率并不完全是独立的，但是相对于拥有多路径的程序比拥有较少路径的程序含有较多缺陷这个来说，它们也足够独立了。条件表达式的增加降低了程序的可靠性。

这个程序由重复的条件表达式混合而成。假如有一个简单的 graphic 编辑器。 这个 figures 需要一个 display() 的方法：

	public void display() {
	  switch (getType()) {
	    case RECTANGLE:
	      //...
	      break;
	    case OVAL:
	      //...
	      break;
	    case TEXT:
	      //...
	      break;
	    default:
	      break;
	  }
	}
	
Figures 也需要一个方法来表明它是否包含一个点：

	public boolean contains(Point p) {
	  switch (getType()) {
	    case RECTANGLE:
	      //...
	      break;
	    case OVAL:
	      //...
	      break;
	    case TEXT:
	      //...
	      break;
	    default:
	      break; 
	  }
	}
	
假如你现在要增加一个 Figure。首先，你需要在每个 switch 表达式中添加一个新子句；第二，为此，你还要修改 Figure 类，保证所有已有的功能都正常；最后，每个需要添加新 figures 的人都需要修改在一个类里面。

这些问题都可以通过将条件表达式转化为消息来解决，不管是父类化还是代理（基于目前的代码是最合理的方式）。重复的条件逻辑或者基于一个条件表达式的处理逻辑非常复杂都最好是转化为消息的方式（来处理）。另外，频繁变化的条件表达逻辑最好是用消息来表示以达到仅修改一处而不影响其它地方。

[Figure 5.6]()

简单来说，条件表达式的优势--当他们简单而自用时候--反而会成为被广泛时候时变成劣势。

### 代理

另外一种方式来达到不同实例不同处理逻辑的目的是将工作代理到一个可能的对象。相同的部分放在调用的类里面，不同的部分放到代理类里面。

一个使用代理来处理差异的例子是 graphical 编辑器中处理用户输入的例子。有时候一个按钮按下代表“创建一个矩形”，有时候代表“移动一个图形”，或者其它。

一种方式是使用条件表达式：

	public void mouseDown() {
	  switch (getTool()) {
	    case SELECTING:
	      //...
	      break;
	    case CREATING_RECTANGLE:
	      //...
	      break;
	    case EDITING_TEXT:
	      //...
	      break;
	    default:
	      break;
	  }
	}

这种做法有之前说的问题：添加一个新工具需要修改现有的代码并且重复条件表达式（in mouseUp(), mouseMove() 等等）导致添加新工具很困难。

子类化并不是解决方案，因为这个编辑器可能需要中途改变工具。代理就可以实现这种动态性：

	public void mouseDown() {
	  getTool().mouseDown();
	}
	
开关语句中的子句就可以移到不同工具的里面。这样，添加新类型就不需要修改这个编辑器或者现有代码了。阅读这样的代码就需要更加全面，因为 mouse-down 的逻辑分布在不同的类里面。了解编辑器特定情况下如何工作需要你知道目前使用的是什么工具。

代理可以保存为一个属性（一个“可插拔对象”），并且他们也可以临时计算出来。JUnit 4 就动态地计算出一个类中需要跑的测试。如果一个类中包含了一种旧形式的测试，就会创建一个代理，但是如果这个类中包含了新的测试，就创建一个新的代理。这是条件表达式（创建代理）和代理的混合使用。	

代理可用于共用代码，也可以用于创建特定实例的行为。一个代理到 Stream 的对象可以作为特定实例的行为，比如运行过程中 Stream 的类型会发生变化，或者 Stream 的实现是所有用户共用的。

一个代理的变形是传递一个代理器到一个代理方法中：

	GraphicEditor
	public void mouseDown() {
	  tool.mouseDown(this);
	}
	
	RectangleTool
	public void mouseDown(GraphicEditor editor) {
	  editor.add(new RectangleFigure());
	}
	
如果一个代理需要给自己发消息，“itself” 是模糊不清的。有时候，消息应该发送给代理对象。有时候，消息应该发送给代理。下面的例子， RetangleTool 添加一个 figure， 但是代理到 GraphicalEditor，而不是自己。这个 GraphicalEditor 应该作为参数传给代理的 mouseDown() 方法，但是在这个例子中，他好像仅仅是简单地在工具中保存了一个引用。传递 GraphicsEditor 使得多个编辑器中可以使用同样的工具，如果不需要这样，那代码可以更简单一些。

	GraphicEditor
	public void mouseDown() {
	  tool.mouseDown();
	}
	
	RectangleTool
	private GraphicEditor editor;
	public RectangleTool(GraphicEditor editor) {
	  this.editor = editor;
	}
	
	public void mouseDown() {
	  editor.add(new RectangleFigure());
	}  			