## 第5章  类

类的出现要追溯到柏拉图时代。柏拉图式的固体是一种类型，世界上可见的一种形式。柏拉图式球体更加贴切但它不够坚固。我们身边到处可以碰到的球形，它们有时候并不完美。

面向对象编程以一种后西方哲学式的方法捡起了这种概念，将程序划分为类。类描述了一堆相似东西的通用特征，而对象就是这些东西。

类在交流时很重要，因为他们潜在地描述了许多特定的东西。类层次的模式拥有实现模式中最长的持续时间。相比之下，设计模式，主要在探讨类之间的关系。

这章节中出现的模式：

+ 类				-----  使用一个类是指：它包含了一些数据和一些逻辑
+ 简化父类名		-----  用一个简单的名字命名类继承结构的根
+ 合理化子类名	-----  命名子类时要突出与父类之间的联系和差异
+ 抽象接口		-----  从实现中分离出接口
+ 接口			-----  特指不经常变化的抽象接口
+ 接口版本化		-----  安全地扩展接口
+ 抽象类			-----  特指某一个可能会被抽象类导致变化的抽象接口
+ 值对象			-----  一个就像数字一样与状态无关的对象
+ 特质化			-----  清晰地表明关联计算中的相似点和不同点
+ 子类			-----  表示普通的子类
+ 实现			-----  用一个方法类包含一系列计算
+ 内部类			-----  在私有类内部打包一些有用的代码
+ 特定对象行为	-----  特定实例的逻辑
+ 附加条件		-----  明确的条件的逻辑
+ 代理			-----  把一系列逻辑代理到某个对象
+ 可插拔选择器	-----  仔细执行一个方法的一系列逻辑
+ 匿名内部类		-----  在方法中覆盖某几个其它方法的一系列逻辑
+ 库类			-----  保存一系列不属于任何对象的静态方法

### 类

数据比逻辑容易改变。正因为如此，类才有用。每个类都在宣告：逻辑被有序组织，比其操作的数据更稳定，而数据被其相关的逻辑用于操作并发生改变。但是，数据会发生改变，逻辑不会变，这件事也不是绝对的。有时候不同的数据值导致逻辑不太一样，有时候不同的条件也会导致逻辑很不相同。而有时候在一个计算进程里面数据不会发生变化。 学习如何将逻辑打包成一个类和区分逻辑中容易变化的部分是进行有效的对象编程的一部分。

将类合理组织是某种形式上的压缩，抽离出父类并在用于子类。向所有压缩技术一样，这导致代码异常难读。你必须理解父类，才能明白子类干了什么。

谨慎地使用继承是进行有效编程的另一方面。创建一个之类就表示：我和父类很像，但是也有不一样。（还记得覆写父类的方法吗？如果我们每次都慎重的选择隐喻，我们会更加擅长编程。）

类比对象的代价要昂贵得多。一个类应该做一些重要的事情。减少我们系统中的类是一种进步，就像我们要避免类变得臃肿一样。

以下的模式解释了我们如何和清晰的类交流。

### 简化父类名

找寻合适的名字是编程过程中最让人满足的时刻。你要和一个个观点作斗争。久而久之，代码就变得异常复杂，尽管它可以变得更好。然后，我们经常听到有人说：“对，这已经（修改名字）在计划当中”。恰当的名字可以帮助之后的简化和改进。

而最最重要的是挑选类名。类是程序设计里面的最关键部分。一旦类名确定了，他的操作名字也确定了。反过来的情况却很罕见，除非刚开始类名就被随意确定。

给类命名时通常会纠结于保持简洁还是含义丰富。比如说可能会有如下关于类名的对话：“你在换算前记得转换了吗？”这时候，名字应该是简洁有力的。然后，有时候为了让名字清晰，我们需要好几个单词来表达。

走出这种困境的做法是使用一些计算领域的隐喻。使用隐喻，即使是一个简单的单词也会带来丰富的含义。比如说，在一个叫 HotDraw 的画图框架里面，我给画图用的一个对象取的第一个名字是 DrawingObject。沃德· 库宁汉姆 总是意味着排版的创始人：画图就像打印一样，也是如何排列页面。页面上的绘画元素都是图形，所以这个类可以叫做 Figure 。使用了隐喻， Figure 比 DrawingObject 更简短，含义更加丰富也更加明确。

有时候，好名字需要花时间。你可能已经写完了代码，甚至过去了好几个礼拜，好几个月，甚至于好几年，突然，你找到一个更好的名字。有时候，你很难确定用哪一个名字：翻遍同义词典，写下来一堆看上去都合适的名字。有时候，你需要忘记它们的功能，相信时间，你的潜意识会帮你选一个好名字。

交流一直是一个找到一个好名字的好办法。对别人解释这个对象的目标和作用可以让我获得更多的理解和想象。这些想象可能导致我找到一个新名字。

给每个重要的类找一个单个单词的名字。

### 合理化子类名

之类的名字有两个功能。它们需要表达它（该子类）像谁并且（与父类比）有什么不同。同样的，它们也需要均衡简洁和含义。不像父类，之类名不会经常在对话中使用，所以它不需要为了简洁牺牲含义。可以在父类名上面添加一些修饰语来命名子类。

一个例外情况是，如果子类是严格地用来实现某种机制并且在其中有扮演了一个重要的角色。这时候，需要给子类一个像父类一样简洁的名字。比如说：HotDraw 有一个类叫 Handle 用来完成特定图形的绘制工作。所以，尽管它扩展了 Figure，它也有一个简洁的名字 Handle。 Handle 有一个完整的继承体系，他们大多数被命名为 StretchyHandle TransparencyHandle 等等。因为 Handle 是他自己的继承体系的根结点，他作为一个简单的父类，而不是合理的子类。

另外一个关于子类命名的麻烦是多继承。多继承体系经常在代理时出现，但是它们同样需要一个好名字。这时候，你要尝试从读者的角度考虑，而不是单纯地在父类名上面附加修饰语。想象别人希望知道这个类更像那个类，用这个父类名作为基本元素。

和别人交流是类名的最终目的。如果考虑到计算机，类名只需要方便计数即可。太长的名字不容易读写。类名应该尽可能地减少占用读者的短期记忆。孤立的类不容易理解和记忆。用类名来讲述你的代码故事。

### 抽象接口

古老的寓言说，我们要对接口编程，而不是实现。另外一个说法是：尽可能地隐藏设计决策。如果我的大多数代码都仅知道我在处理一个集合，那我就能比较自由地修改类的实现。然后，有时候，你不得不将你的混乱的类提交出去，以便计算机能够工作。

这里所说的“接口”，是指一系列没有实现的操作。他对于 Java 来说可以是一个接口，也可以是一个父类。接下来的模式将会介绍那种形式更合适。

每一层接口都有代价。他增加了学习，理解，文档维护，调试，组织，浏览和命名的成本。尽可能多地使用接口并不会使软件成本最低。只在你需要灵活性的地方使用接口。因为你有时候不能提前哪里需要接口来减少开支，可以尝试在需要灵活性的地方推测接口是否合适。

多数时候，我们抱怨一个软件不够灵活，我们有一堆方法可以让它变得更灵活。从最基本的比如每个 integer 型的占用空间大小到新的业务模型，大多数软件不需要做到极致（灵活）。

另外一个使用接口的好处是软件的不可预测性。软件工业上似乎信奉一个观念：如果我们的软件设计得足够好，那就不需要改变。我最近看到了导致软件改变的一些理由。其中包括程序员没根据需求实现，客户改变了主意等等。其中漏掉了很重要的一点：和你变更。它假定所有变更都是不应该存在的。为什么每天都要天气预报？因为天气是不可预测的。那为什么系统需要保持灵活？因为需求和技术都是不好预测的。即使客户马上就要了，我们也不能降低开发好一个系统的要求，但是我们可以适当的限制对未来系统的猜测。

总的来说，灵活性的需求，灵活性的代价，灵活性的不确定性作为我们选择使用使用灵活性的依据。介绍灵活性的代价是因为你需要在现有系统上修改代码。如果你漏掉了某处需要修改的地方，那未来就存在风险，开发框架那一章重点说明个这个话题。

Java 里面的两种机制：抽象街口，父类和接口有不一样的代价。

### 接口

一种说法：“这就是我需要实现的目标，其它的细节我不关心”就是描述了一个 Java 中的接口。接口是 Java 中最早引入的一个重要方法。接口是一个很好的平衡。它拥有多继承的灵活性，却又避免了复杂性和歧义。一个类可以声明其实现了多个接口。接口只暴露操作，而没有属性，所以它能够在接口发生改变时有效地保护使用者。

因为接口改变需要对所有的实现改变，它就会对自身的改变更慎重。任何对接口的增加或者修改都需要修改所有的实现。如果你不能够修改实现，接口通常会标明修改并在未来的版本中改变。

接口不利于交流的一点是他需要所有的操作是公开的（Public）。我通常更希望它们是包可见的。如果自己使用，那接口都是公开也没关系，但是如果有很大的用户群，那最好是保持谨慎，这样能在未来需要变更时更方便。

有两种接口命名的方法，取决于你怎么考虑这个接口。还没有实现的类似于类的接口可以用类的方式命名（简化父类，合理化子类）。这样的方式的一个问题是你可能在给类命名时就将好名字用掉了。一个 File 的接口的实现可能只能命名为 ActuralFile， ConcreteFile 或者 FileImpl（既包含了后缀，又是简写）。一般情况下，说明清楚一个东西是一个具体对象还是抽象对象是很重要的，说明一个抽象对象是实现了一个接口还是继承了一个父类是相对不这么关心的。这种命名方式能够很好地体现接口和父类的差异，也能够在需要的时候及时改变。

有时候，简单地命名一个实际类比一个隐藏接口的沟通性更重要。这种情况下，在接口前面加个 “I”更好。比如接口叫 “IFile”， 类名就可以简单地叫做 File。

### 抽象类

在 Java 里面，另外一个抽象接口和和具体实现的区别是使用父类。这种情况下，父类是抽象的，并且不管它是不是抽象的，在运行时都可以被任何子类代替。

而为什么我们要使用抽象类，而不是接口，主要是两个原因：接口会发生变化或者需要实现多个接口。抽象接口需要支持两种变化：实现发生变化和接口本身发生变化。 Java 里面的接口对否后者的支持很弱。每次接口发生改变都需要改变所有实现。对于一些被广泛使用的接口，这很容易导致原有设计彻底瘫痪，唯一的解决方案就是对接口进行升级并在以后的版本里面修改。

抽象类则没有这种限制。只要指定默认实现，就可以在不扰乱既有实现的基础上添加新特性。

抽象类的一个限制是它的实现者只能使用他作为唯一的父类，如果需要其它的类，那他们必须以接口的形式实现。

在一个类上使用 Abstract 可以告诉读者，他们要使用这个类的话必须实现一些东西。最好的情况是让继承树的根类成为一个抽象类。一旦走上抽象化这条路，很容易就过度抽象。尽量让根类实例化可以帮助消除抽象你排除抽象来尽力做好自己。

接口和类继承不总是相对的。你可以用接口来表达：“这里说明了如何使用这些功能”，而一个父类这代表了：“这是该功能的一种实现”。所以，接口里面的变量需要注明类型，这样在需要的时候就可以重新实现。


### 版本化接口

当你想改变接口，但是又不能改的时候，你会怎么办呢？比如说，你想添加一种操作。因为添加操作会让所有已有的实现瓦解，所以你不能这么做。但是，你可以创建一个新的接口，然后扩展原来的接口，并在里面添加新操作。需要新操作的用户就使用新接口，而老用户依然使用旧接口。每次当你需要调用新操作，你都需要检查类型，并向下转型到新类型。

举个例子：

	interface Command {
	  void run();
	}

一旦这个接口已经发布，并且被许多人使用，修改他就会变得很麻烦。然后，需要添加一个 undo 操作。新版本的接口就要像这样：

	interface ReversibleCommand extends Command {
	  void undo();
	}	
	
原有的接口依然可以工作， ReversibleCommand 接口也可以代替 Command 接口，如果要使用新接口，

	...
	Command recent = ...
	if recent instanceof ReversibleCommand) {
	  ReversibleCommand downcasted = (ReversibleCommand) recent;
	  downcasted.undo();
	}
	...
	
使用 instanceof 减少了代码的灵活性。但是，这也是合理的，因为他实现了接口的升级。如果你有许多这样的接口，那客户端就需要许多额外的工作来处理这些差异。这就是需要重新思考设计的时候了。

可选接口是对一个糟糕问题的糟糕解决方案。接口并不能像他的实现一样易于修改。接口其实经常变化，就像我们做的设计一样。我们从实现和维护中的经验中学习设计。可选的接口创造了一种新的编程语言，它像 Java ，但是又有自己的新规则。编写新语言和编写应用程序是完全不一样的。所以，如果你也需要扩展接口，现在知道了怎么做了。


### 值对象
   