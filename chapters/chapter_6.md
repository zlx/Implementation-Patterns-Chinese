## 第六章

### 概述

这一章重点介绍了如何来使用状态来达到沟通的目的。对象就是行为和状态的封装，一个是对外部世界的展现，一个是用来支持行为的。对象的一个优势是将程序的所有状态划分成一个个小块，每一个仅影响自己的那一部分计算逻辑。一堆状态混杂在一起，胡乱地引用，导致了代码的每处改动变得困难，因为状态的一点变化可能导致的影响无法预测。通过对象，我们就可以比较简单地分析一处代码改动可能的影响，因为状态的命名空间让这件事变得容易。

这章包含了以下模式：

+ 状态		---	根据时间计算变量的值
+ 限制使用	---	限制状态的使用来维持灵活性
+ 直接引用	---	在一个对象内部使用状态
+ 间接引用	---	通过方法来使用状态以保持更大的灵活性
+ 通用状态	---	将状态的共同部分存储到一个类的所有实例中
+ 多样状态	---	表示一个状态在不同对象之间的不同
+ 外部状态	---	代表特定对象的特殊目的状态
+ 变量		---	变量提供了使用状态的一个命名空间
+ 本地变量	---	本地变量保存了一小块作用域的状态
+ 属性		---	属性存储了一个对象整个生命周期中的状态
+ 参数		---	参数在调用方法时用于和状态沟通
+ 返回值参数	---	传递一个参数来保存多个方法的复杂结果
+ 参数对象	---	将频繁使用的参数列表封装成对象
+ 常量		---	表示像常量一样不会变化的状态
+ 角色相关名	---	根据计算中一个结果之后行为来命名变量
+ 声明类型	---	声明变量的一个类型
+ 初始化		---	尽可能根据声明来初始化变量
+ 预初始化	---	在创建实例时初始化属性
+ 懒初始化	---	在第一次使用时初始化属性


### 状态

世界一直存在，如果一分钟之前，太阳高高地挂在天空中，你可以确定现在它也在高空中，只不过移动了一点点。如果我仔细计算，我可以根据之前的观察预测它的新位置会在哪里，这需要地球自转的知识和过去这段时间的长短。

看清世界上事情发展的规律已经被证明是非常有帮助的。我住的地方的美国本土人士春天观察麦克洛克林山。当积雪慢慢融化，露出山峰的轮廓，就是到罗格河抓三文鱼的时候了。山上的雪的状态可以看出什么时候可以到附近去游泳了。

当先驱们在讨论计算机程序哲学的时候，它们确定了这种状态变更的规律。基于学习，人类大脑产生了许许多多不同的处理状态的策略。

然后，状态依然给程序员造成了许多麻烦。即使你给状态做了一个很小的假定，也可能让你的代码面临风险。你可能假定不正确，或者状态可能会变化。许多很棒的工具，比如说自动重构器，如果没有状态会更容易实现。最后，并发和状态在一起很难处理。如果没有状态的话，许多多线程问题都不存在了。

函数式语言完全移除了状态的变化。然后它们没有一个流行起来。我认为状态是一种很有价值的说法，因为我们的大脑是结构化的并且适应了处理状态变化的情况。单纯赋值或者无变量的程序让我们抛弃许多有效的策略。

面向对象语言是采用复制的方式来处理状态的。它们将状态切分为单独的小块，并且每块之间严格禁止访问，这样来避免了（被别人改变的）状态所带来的问题。相对于百万字节来说，跟踪记录少数几个字节相对更容易一些。对状态的不正确假定的问题依然存在，但是通过对象，你可以方便并且清楚地查看一个变量的所有引用。

管理状态的关键是将相似的状态放在一起，保证不同的状态分开。关于如何确定两个状态是一样的两个方法是：它们出现在同一个计算过程和它们同时产生同时消亡。如果两个状态一起使用，并且具有相同的生命周期，那将它们放在一起更好。

### 访问

不同程序语言的一种归类方法是访问已存储的变量的方式和调用计算过程的方式。这两个概念的相互理解的。访问内存就像调用函数来返回当前存储的值。调用函数就像读取上一次计算内容的的返回值在内存中的位置。尽管如此，程序语言还是可以根据调用计算过程和访问内存来划分，所以我们需要知道这两者之间有什么不同。

确定那些要存储，那些需要计算影响了程序的可读性，灵活性和性能。有时候这些是相互冲突的。有时候内容变化了，导致了昨天两者之间的很好的平衡又变得无效了。做出可用的决定并考虑之后可能的变化的灵活性是开发优秀软件的关键。考虑到未来可能的变化，在存储和计算之间取得清晰地平衡就很重要了。

对象的一个目的是管理存储。每个对象就像一个拥有自己的内存的小计算机，相互之间独立。当代语言，包括 Java，通过访问级别来隔离不同的对象。减少内部对象的访问并不值得丢失了对象之间的独立性。


### 直接访问

最简单的方式来取数据和存数据就是使用了直接变量访问。

	x = 10;

直接变量访问有表达式清晰的好处。当我看到 x＝10； 我很清楚这是要做什么。这种清晰也导致丧失了一些灵活性。如果我直接将一个值存在一个变量中，那我也不能做其它额外的东西了。如果我将一个值存储在那些程序其它部分会使用的变量中，然后它们会根据程序的不同发生变化。

直接访问的另外一个不好的地方是它是一个实现细节，层级比我们编程的大多数想法都要低。将一个变量设置为 1 可能会表示我的车库门被打开了，但是这种代码并没有太多的可读性。比较以下几种写法：

	doortgister = 1;   或者  openDoor();   或者  door.open();
	
我们在编程时候，大多数时候并不考虑具体存储。大量的直接访问会导致代码混乱，丧失可读性。对那些真正需要考虑存储的地方，我直接访问来实现我的想法。不同的程序对存储的要求不同，所以没有一个规则来适用任何人的情况。人们开始想出以下规则：只在设置方法或者构造器里面直接访问。直接访问只出现在一个类或者一个类及其父类或者在一个单独的包里面。没有普适的规则。程序员需要思考，沟通和学习。这是成为专业开发者的一部分。

### 间接访问

你可以隐藏访问并且在方法调用后面修改状态。这种设置方法在付出清晰性和直接的代价下获得了灵活性。客户端不再直接存储一个值。	这样，你就可以在不影响客户端的前提下修改存储实现。

我操作状态的一个基本策略是允许一个类中直接访问，客户端则采用间接访问。这个策略的好处是可以保证大多数时候修改状态是清晰和直接的。注意：如果对一个对象的大多数访问都是在对象外的，那可能隐藏着一个很深的设计隐患。

另外一种策略是只使用间接访问。我发现这样会导致丧失清晰性。大多数取值和设值方法是简单的。它们通常超过了大多数真正有用的方法，导致代码很难读。所有的取值和设值方法是临时的。大多数时候，我们并不去深究这个计算应该属于哪里，而是直接在某个地方实现，然后调用设置方法来存储状态。

一种明确使用间接访问的地方是两个相伴的数据。有时候这是很明显的，比如在缓存值中：

	Rectangle void setWidth(int width) {
	  this.width = width;
	  area = width * height;
	}

有时候却并不明显，在一个监听器中：

	Widget void setBorder(int width) {
	  this.width = width;
	  notifyListeners();
	}

这样的相伴数据是非常不好看的（很容易忘记维护这种关系）但是却是最好的选择。这种情况下，间接访问是最恰当的。


### 公共状态

很多计算使用这些相同的数据。如果你发现了这种计算过程，尝试在类中声明属性。比如说：所有计算笛卡尔点的地方都需要横坐标和纵坐标。因为所有点都需要这些值，它们可以更清晰地表示为：

	class Point {
	  int x;
	  int y;
	}
	
和直接使用状态变量相比，这种方式无疑更清晰可读。你的读者可能希望知道你的对象需要什么才能调用成功。公共状态可以让这个更清晰和恰当。

一个对象里面的公共状态应该有相同的作用域和生命周期。有时候我还被引导去使用一个单独的属性，或者说只有当某个方法计算之后才有效。这种情况下，我就知道应该去修改代码了，找到其它地方来存储数据，可能是一个参数或者一个帮助对象。

	  	





















