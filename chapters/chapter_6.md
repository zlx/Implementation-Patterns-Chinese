## 第六章

### 概述

这一章重点介绍了如何来使用状态来达到沟通的目的。对象就是行为和状态的封装，一个是对外部世界的展现，一个是用来支持行为的。对象的一个优势是将程序的所有状态划分成一个个小块，每一个仅影响自己的那一部分计算逻辑。一堆状态混杂在一起，胡乱地引用，导致了代码的每处改动变得困难，因为状态的一点变化可能导致的影响无法预测。通过对象，我们就可以比较简单地分析一处代码改动可能的影响，因为状态的命名空间让这件事变得容易。

这章包含了以下模式：

+ 状态		---	根据时间计算变量的值
+ 限制使用	---	限制状态的使用来维持灵活性
+ 直接引用	---	在一个对象内部使用状态
+ 间接引用	---	通过方法来使用状态以保持更大的灵活性
+ 通用状态	---	将状态的共同部分存储到一个类的所有实例中
+ 多样状态	---	表示一个状态在不同对象之间的不同
+ 外部状态	---	代表特定对象的特殊目的状态
+ 变量		---	变量提供了使用状态的一个命名空间
+ 本地变量	---	本地变量保存了一小块作用域的状态
+ 属性		---	属性存储了一个对象整个生命周期中的状态
+ 参数		---	参数在调用方法时用于和状态沟通
+ 返回值参数	---	传递一个参数来保存多个方法的复杂结果
+ 参数对象	---	将频繁使用的参数列表封装成对象
+ 常量		---	表示像常量一样不会变化的状态
+ 角色相关名	---	根据计算中一个结果之后行为来命名变量
+ 声明类型	---	声明变量的一个类型
+ 初始化		---	尽可能根据声明来初始化变量
+ 预初始化	---	在创建实例时初始化属性
+ 懒初始化	---	在第一次使用时初始化属性


### 状态

世界一直存在，如果一分钟之前，太阳高高地挂在天空中，你可以确定现在它也在高空中，只不过移动了一点点。如果我仔细计算，我可以根据之前的观察预测它的新位置会在哪里，这需要地球自转的知识和过去这段时间的长短。

看清世界上事情发展的规律已经被证明是非常有帮助的。我住的地方的美国本土人士春天观察麦克洛克林山。当积雪慢慢融化，露出山峰的轮廓，就是到罗格河抓三文鱼的时候了。山上的雪的状态可以看出什么时候可以到附近去游泳了。

当先驱们在讨论计算机程序哲学的时候，它们确定了这种状态变更的规律。基于学习，人类大脑产生了许许多多不同的处理状态的策略。

然后，状态依然给程序员造成了许多麻烦。即使你给状态做了一个很小的假定，也可能让你的代码面临风险。你可能假定不正确，或者状态可能会变化。许多很棒的工具，比如说自动重构器，如果没有状态会更容易实现。最后，并发和状态在一起很难处理。如果没有状态的话，许多多线程问题都不存在了。

函数式语言完全移除了状态的变化。然后它们没有一个流行起来。我认为状态是一种很有价值的说法，因为我们的大脑是结构化的并且适应了处理状态变化的情况。单纯赋值或者无变量的程序让我们抛弃许多有效的策略。

面向对象语言是采用复制的方式来处理状态的。它们将状态切分为单独的小块，并且每块之间严格禁止访问，这样来避免了（被别人改变的）状态所带来的问题。相对于百万字节来说，跟踪记录少数几个字节相对更容易一些。对状态的不正确假定的问题依然存在，但是通过对象，你可以方便并且清楚地查看一个变量的所有引用。

管理状态的关键是将相似的状态放在一起，保证不同的状态分开。关于如何确定两个状态是一样的两个方法是：它们出现在同一个计算过程和它们同时产生同时消亡。如果两个状态一起使用，并且具有相同的生命周期，那将它们放在一起更好。

### 访问

不同程序语言的一种归类方法是访问已存储的变量的方式和调用计算过程的方式。这两个概念的相互理解的。访问内存就像调用函数来返回当前存储的值。调用函数就像读取上一次计算内容的的返回值在内存中的位置。尽管如此，程序语言还是可以根据调用计算过程和访问内存来划分，所以我们需要知道这两者之间有什么不同。

确定那些要存储，那些需要计算影响了程序的可读性，灵活性和性能。有时候这些是相互冲突的。有时候内容变化了，导致了昨天两者之间的很好的平衡又变得无效了。做出可用的决定并考虑之后可能的变化的灵活性是开发优秀软件的关键。考虑到未来可能的变化，在存储和计算之间取得清晰地平衡就很重要了。

对象的一个目的是管理存储。每个对象就像一个拥有自己的内存的小计算机，相互之间独立。当代语言，包括 Java，通过访问级别来隔离不同的对象。减少内部对象的访问并不值得丢失了对象之间的独立性。


### 直接访问

最简单的方式来取数据和存数据就是使用了直接变量访问。

	x = 10;

直接变量访问有表达式清晰的好处。当我看到 x＝10； 我很清楚这是要做什么。这种清晰也导致丧失了一些灵活性。如果我直接将一个值存在一个变量中，那我也不能做其它额外的东西了。如果我将一个值存储在那些程序其它部分会使用的变量中，然后它们会根据程序的不同发生变化。

直接访问的另外一个不好的地方是它是一个实现细节，层级比我们编程的大多数想法都要低。将一个变量设置为 1 可能会表示我的车库门被打开了，但是这种代码并没有太多的可读性。比较以下几种写法：

	doortgister = 1;   或者  openDoor();   或者  door.open();
	
我们在编程时候，大多数时候并不考虑具体存储。大量的直接访问会导致代码混乱，丧失可读性。对那些真正需要考虑存储的地方，我直接访问来实现我的想法。不同的程序对存储的要求不同，所以没有一个规则来适用任何人的情况。人们开始想出以下规则：只在设置方法或者构造器里面直接访问。直接访问只出现在一个类或者一个类及其父类或者在一个单独的包里面。没有普适的规则。程序员需要思考，沟通和学习。这是成为专业开发者的一部分。

### 间接访问

你可以隐藏访问并且在方法调用后面修改状态。这种设置方法在付出清晰性和直接的代价下获得了灵活性。客户端不再直接存储一个值。	这样，你就可以在不影响客户端的前提下修改存储实现。

我操作状态的一个基本策略是允许一个类中直接访问，客户端则采用间接访问。这个策略的好处是可以保证大多数时候修改状态是清晰和直接的。注意：如果对一个对象的大多数访问都是在对象外的，那可能隐藏着一个很深的设计隐患。

另外一种策略是只使用间接访问。我发现这样会导致丧失清晰性。大多数取值和设值方法是简单的。它们通常超过了大多数真正有用的方法，导致代码很难读。所有的取值和设值方法是临时的。大多数时候，我们并不去深究这个计算应该属于哪里，而是直接在某个地方实现，然后调用设置方法来存储状态。

一种明确使用间接访问的地方是两个相伴的数据。有时候这是很明显的，比如在缓存值中：

	Rectangle void setWidth(int width) {
	  this.width = width;
	  area = width * height;
	}

有时候却并不明显，在一个监听器中：

	Widget void setBorder(int width) {
	  this.width = width;
	  notifyListeners();
	}

这样的相伴数据是非常不好看的（很容易忘记维护这种关系）但是却是最好的选择。这种情况下，间接访问是最恰当的。


### 公共状态

很多计算使用这些相同的数据。如果你发现了这种计算过程，尝试在类中声明属性。比如说：所有计算笛卡尔点的地方都需要横坐标和纵坐标。因为所有点都需要这些值，它们可以更清晰地表示为：

	class Point {
	  int x;
	  int y;
	}
	
和直接使用状态变量相比，这种方式无疑更清晰可读。你的读者可能希望知道你的对象需要什么才能调用成功。公共状态可以让这个更清晰和恰当。

一个对象里面的公共状态应该有相同的作用域和生命周期。有时候我还被引导去使用一个单独的属性，或者说只有当某个方法计算之后才有效。这种情况下，我就知道应该去修改代码了，找到其它地方来存储数据，可能是一个参数或者一个帮助对象。


### 变量状态

有时候同样的对象根据使用情况的不同需要不同数据。它不仅仅是值不同，整个展现的形式都是不一样的。

变量状态常用于存储成 map 的形式，key用来作为元素的名字，值用来作为数据的值。

	class FlexibleObject {
	  Map<String, Object> properties = new HashMap<String, Object>();
	  Object getProperty(String key) {
	    return properties.get(key);
	  }
	  void setProperty(string key, Object value){
	    properties.set(key, value);
	  }
	}

变量状态比公共状态灵活一些。它主要的问题在于沟通性不够好。只有变量状态可以正常工作的函数如何在对象中展现呢？只有仔细阅读代码甚至于查看执行过程才能够帮助你回答这个问题。

我看到过有人过度使用变量状态的代码。每个对象都有几乎相同的属性对。我更希望直接使用属性声明来表示这些相同的东西。

一种情况下正适合变量状态的是一个属性的状态暗示了另外一个属性的需要。比如说：如果我有一个控件 bordered 标志为 true ，我就可以有 borderWidth 和 borderColor 。这时候，我可以使用变量状态，就像表 6.1 所示：

[Figure 6.1]()

公共状态也可以表示，就像表 6.1 下面的一样。

公共状态的解决方案违反了一个原则：对象中的所有变量应该具有相同的生命周期。多态提供了更清晰的解决方案。一种代表了无边的状态，另一种代表了有边的状态。Bordered 有公共状态代表它的参数。

[Figure 6.2]()
		  	
一些变量共用同一个前缀就代表了可能需要一个帮助对象。

尽可能地使用公共状态，在一个可能或者不可能依赖使用情况的属性上使用变量状态。

### 外部状态

有时候你的程序需要一个状态，但是系统的其他部分并不需要。比如说：对象存储在哪里是持久化机制关心的，但是其它部分并不关心。将这些数据存在属性里面会破坏对称原则。所有其它属性是整个系统需要的。

保存一个对象相关的状态在靠近使用的地方，而不是对象属性上。持久化机制将维护一个 IdentityMap 它的key是要保存的对象，value是保存地址的信息。

外部对象一个薄弱之处在于它使得拷贝对象变得困难。复制一个包含外部状态的对象不仅仅是复制它的属性。而是，所有和它相关的外部对象都需要正确地复制，这取决于具体的情况。常规的检查并不会检测一个对象关联的所有数据。因为这些麻烦，外部状态很少使用，除非必要。

### 变量

在 Java 里面，对象是根据变量来指向的。读者需要知道作用域，生命周期，角色和变量在运行时的类型。因为我们已经有根据变量交流的整套的方法，所以用简单的变量名来简化代码是非常棒的。

变量的作用域，变量能够被引用到的范围，可以有三种类型：本地的，当前作用域可见；属性，可以在一个对象的任何地方可见；静态的；所有类和对象可见。属性的作用域可以根据 public, package, protected 和 private 修改

如果你作用域限制比较宽松，那就意味着从名字清晰地看出它们之间的区别就很重要。然后，为了减少伴随现象，你最好尽量使用临时变量和属性，偶尔使用静态变量和私有作用域的修改。通过使用这种限制，你就告诉读者他们看到的是临时变量还是属性。如果有声明，那就是临时变量，否则就是属性。这估计需要在变量里面包含作用域信息。作为回报，你就拥有了可控地，易读的变量名。所有这些的前提是你可以将你的代码切分成小块，这是你可以用来实现模式的能力，尤其是组合方法。

变量的生命周期可以比它们的作用域短。属性可以仅在某些方法触发后有效。但这是很丑陋的。努力使得变量的生命周期和它们的作用域相当。进一步地，保证它们的兄弟变量拥有同样的生命周期。

变量类型是一个可以通过类型声明来达到充分沟通的目的。保证声明类型可以尽可能清晰地沟通。这个建议的一个例外是当变量的名字拥有多个值时（可能包含了一个集合），可能是多元的。单值和多值变量的区别对与读者来说很重要。

通过作用域，生命周期和类型，名字可以用来达到沟通的目的。通过减少需要表达的信息，我们可以尽可能地简化名字。

### 临时变量

临时变量仅从声明开始到他们的作用域结束之间可以访问。遵循信息应该尽可能少地传播的原则，临时变量应该在将要使用时声明并且尽可能地在最深的作用域。

这里有一堆临时变量的角色：

+ 集合：用来保存之后可能使用的信息。通常这种类型是以结果的形式返回的。可以用 result 或者 results 命名。
+ 计数：一个特殊的集合，用来保存其它对象的数量。
+ 解释：如果你有一个巨复杂的表达式，将每一部分赋给一个临时变量有助于帮助读者理解。

	int top=...;
	int left=...;
	int height=...;
	int bottom=...;
	return new Rectangle(top, left, height, eidth);
	
即使不需要计算，解释用的临时变量也对长长的，复杂的表达式有帮助。

解释临时变量经常意味着需要帮助方法。表达式就是方法体，临时变量则是方法名。有时候这样可以用来简化方法调用，有时候又可以用来移除重复表达式。

+ 重用：当一个表达式的值变了，但是你又想多次使用相同的值，可以将它保存在临时变量中。比如说：如果多个对象需要相同的时间戳，你不能每次获取最新时间：

	for(Clock each: getClocks())
		each.setTime(System.currentTimeMillis());
	
而使用临时变量来保存时间而达到目的：
	
	long now=System.currentTimeMillis();
	for(Clock each: grtClocks())
		each.setTime(now);	

+ 元素：最后一个临时变量的用法是保存一个集合中的当个元素。在上面的例子中，each 是清晰、简单的名字。如果你要问“each what？”，可以看一看 for 语句。

对于嵌套循环，将集合的名字加到临时变量的最后来区分：

	broadcast() {
		for (Source eachSender: getSenders())
			for(Destination eachReceiver: getReceivers())
				...;
	}

### 属性

属性的作用域和生命周期和它附属的对象是一致的。因为属性主要是用于对象，不管是在类的开始还是最后声明。在最前面声明，可以帮助读者更好地阅读剩下的代码。在最后面声明则表示：“逻辑为王，数据只是实现细节”。尽管我同意在对象编程中逻辑要比数据重要，我依然喜欢先看声明语句，在阅读剩下的代码。

你还可以将属性声明为 final。这就告诉读者，运行期间这个属性的值不会改变。当我在不确定属性会不会变时，我不会明确声明属性（是不是 final）。这个额外获得的清晰性并不值得所带来的额外复杂性，但是如果我的代码可能以后被其他人修改，最好还是搞清楚要不要使用 final。

以下属性的作用并没有临时变量的那么全面。尽管如此，下面是属性的一些公共作用：

+ 帮助：帮助属性保存被多个方法使用的对象的引用。如果一个对象被多个方法使用，考虑用帮助属性代替。

+ 标志：布尔型的属性表示：这个对象有两种模式。如果这个标志还有一个设值方法，那就代表了：这个对象的行为在其生命周期里可能发生变化。在特定条件下使用标志属性是挺好的。如果代码需要基于拷贝的标志做决定，考虑使用策略属性。

+ 策略：当你需要需要选择如何表现某一部分计算过程，将计算的结果保存在一个属性当中。如果这种变化在一个对象的生命周期都不出现，就在对象构造函数中设置，否则，就提供方法来改变。

+ 状态：当对象代理时，状态属性和策络属性很像。然而，状态属性，调用时会自己设置状态。策略属性则通常是别的对象来修改。状态机的实现是非常难读的，因为状态和过渡不在一起。但是对于简单的状态机，它就足够了。

+ 组合：这种属性保存对象所拥有的数据和其它对象引用。

### 参数

除了非私有变量（属性和静态属性），对象间沟通的方式就是传递参数。因为非私有参数表明了类之间的强伴随关系，并且这种关系会随着时间逐步变得更强，在静态属性和参数都可以使用的情况下，参数是更好的选择。

单个参数的伴随现象比对象之间的引用的伴随想象要轻微得多。比如说：在树结构内部的计算通常需要知道一个节点的父节点。相对于直接保存一个父节点的引用，传递参数所带来的影响要小得多。当父节点没有引用时，他就可能有多个树的子树。

[Figure 6.3]()

如果一个对象到另一个对象的许多消息都需要相同的参数，最好将对象的引用作为参数。参数是捆绑在对象上的轻型线程，就像格列佛和小人国一样，但是足够多的参数也可能导致对象难以改变。

[Figure 6.4]()

假如一段这样的代码：

	Server s = new Server();
	s.a(this);
	
变成了这样的：
	
	Server s = new Server();
	s.a(this);
	s.b(this);
	s.c(this);
	s.d(this);
	s.e(this);

这是，你如果改用引用，就更简单一点。

	Server s = new Server(this);
	s.a();
	s.b();
	s.c();
	s.d();
	s.e();
	
### 收集参数

从多个方法调用中返回结果需要以某种方式合并结果。一种方式是保证所有方法又返回值，这种方式当返回值比较简单，比如 Integer 是有效的。

	Node 
	int size() {
	  int result=1;
	  for(Node each:getChildren())
	    result += each.size();
	  return result;
	}

当合并结果并不是简单的相加时，这时候传第一个收集参数来收集结果更直接。比如说：分析树时，收集参数很有用。

	Node 
	asList() {
	  List results = new ArrayList();
	  addTo(results);
	  result results;
	}
	addTo(List elements) {
	  elements.add(getValue());
	  for(Node each: getChildren())
	    each.addTo(elements);
	}	
	
一些另外的更加复杂的情况，比如说 GraphicsContext 在树之间传递或者 TestResult 在测试的树的周边使用。

### 可选参数

有些方法会接受一个参数，如果没传的话赋予一个默认值。这时候，将一些强制的参数放在参数列表的前面，可选参数放在后面。这可以保证尽可能的参数相同，可选参数出现在最后。

ServerSocket 构造器就包含了可选参数。基本构造器不带参数，也可以传递一个端口号，还可以传递端口号和 backlog 的长度。

public ServerSocket()
public ServerSocket(int port)
public ServerSocket(int port, int backlog)

关键词语言可以更直接地表示可选参数。因为 Java 只有位置参数，一个参数是不是可选只能靠约定。有些人把这种叫做望远镜参数模式，提供了如何相互收集参数。

### 可变长参数

有些方法可以结构任意多个给定类型的参数。一个简单的做法是始终传递一个集合作为参数。调用这样的方法，中间的参数的展现是杂乱的：

Collection<String> keys = new ArrayList<String>();
keys.add(key1);
keys.add(key2);
object.index(keys);

这个问题是普遍的，因为 Java 提供了一个机制来传递可变长的参数。通过这样 method(Class... classes) 来声明一个方法，客户端就可以通过传递任意多个参数来调用方法。

object.index(key1, key2);

可变长参数必须是最后一个参数。如果一个方法既有可选参数，也有可变长参数，可选参数必须在可变长参数之前。


### 参数对象

如果一组参数经常被用于作为参数使用，可以考虑构造一个把它们作为属性的对象，然后传递对象。一旦你用对象代替了一组参数，看看是不是有些方法就用到了这个参数对象里面的属性，这样你就可以将它们归为参数对象的方法。

比如说，在 Java 里面，用图形库来画矩形需要 x, y, width 和 height 几个参数。有时候这四个参数传递了很多层，结果就是它们会变得很长，很难理解。

	setOuterBounds(x, y, width, height);
	setInnerBounds(x, y, width - 4, height - 4);
	
使用对象来代替，就可以直接这样：

	setOuterBounds(bounds);
	setInnerBounds(bounds.expand(-2));

使用参数对象可以简化代码，阐述意图，并且提供一个可以扩大合并长方形的算法的地方，这样就可以在需要的时候全局替换了。许多牛逼的对象都是从参数对象开始的。

如果引入参数对象最初的目的是提高可读性，参数对象现已经成为了存放逻辑的重要地方。参数经常一起出现是一个它们关联性很强的信号。一个包含这些参数的类就是在说：这堆数据是强相关的。

参数对象不被经常使用的一个原因是性能--分配这些属性需要时间。大多数时候，这并不是问题。如果对象分配成为了瓶颈，参数对象可以内联，在需要的地方变回参数列表。最好的代码优化是可读性，重构，测试；参数对象就是达到这个目的的。	

### 常量

有时候你需要在多个对象使用相同但又不会变的数据。如果这些值在编译期就已经知道，就可以声明为 static final，然后在程序的其它地方引用。通常我们会把常量的名字用全部都是大写字母表示，来表明它们并不是普通变量。

使用常量很重要的一部分是在使用它们时候避免一整个类都是错误。如果你的代码中有使用 5 ，然后你想把 5 都改为 6 .很容易就遗漏某些地方。如果 5 代表了两个含义，比如说有时候代表：“画一条边框“或者“确认包之后需要做什么”，那么，修改这个常量就更加容易出错了。使用常量最有力的理由是：你可以使用常量来表示他说代表的值。读者更容易理解 Color.WHITE 而不是 0xffffff。如果颜色的编码变了，使用常量的代码不需要做改变。

一个常见的使用常量的场景是：在一个接口中表达多种消息。比如说：用 setJustification(Justification.CENTERED) 来将文本居中对齐。这种 API 的一个好处是你可以直接通过添加新的常量来添加新类型，而不需要修改实现。然而，和每种情况一个单独的方法相比，这种方式又有点不同。这种情况下：上面的情况下可以写成：justifyCentered()。对应每一种常量都可以用一个单独的方法来表示。

### 根据角色命名

你如何确定一个变量的名字？许多相互冲突的限制都会影响这个。我想用我的名字来表示意图，这样通常会造成很长的名字。我更喜欢用更短的名字来简化代码。名字会在输入时读好多遍，所以名字应该保持可读性，而不是更容易输入。变量将被使用的方式和数据代表的角色都是需要考虑的问题。

当我试着理解一个变量的时候，需要很多信息。为什么每次我转而将相同的信息存到变量里面，都需要一遍又一遍地告诉编译期这个变量的类型呢？我发现在变量名里面包含类型信息可以在一些语言中并不能有效避免类型错误，比如 C。 Java 提供了足够的支持来避免类型错误。

如果我希望知道一个变量的类型，我的 IDE 可以告诉我。使用短的，组合的方法也更快的列出最常使用的变量，临时变量和参数。

另外一个方面是读者必须知道变量的作用域。有些变量名会将作用域包含在名字里面，所以 fCount 是一个属性，lCount 是一个临时变量。同样的，通过组合相近的方法，我发现我很少会混淆变量的作用域。如果我在这个方法里面没看到定义，那就可能是一个属性。（我使用其它技术来避免使用过多的静态属性）。

这就导致了变量的角色作为我命名变量的主要依据，这通常可以找到一个短的，清晰的名字。如果我纠结于找一个好名字，很有可能是我还没有完全理解整个计算过程。

下面是我最近使用的变量名：

+ result	-- 存储了一个函数的返回值
+ each		-- 存储了一个集合中的每个迭代的元素
+ count		-- 存储计数值

如果我有多个变量都可以给同样的名字，我倾向于命名为：eachX eachY 或者 rowCount  columnCount

我们有时候倾向于缩写变量名。这可以减少阅读的成本。因为每段代码一旦写出来都可能被多吃阅读，这是一个节约时间的做法。有时候我喜欢用多个单词来命名变量，导致了变量名过长而不便于输入。这时候，我会观察周围，为什么我需要这么多单词来将它和其它对象做区分？通常，这会让我简化我的设计，让我写出更短的变量。

总结一下：我通过变量名来表达变量的所扮演的角色。另外一些重要的方面--生命周期，作用域，和类型---可以通过内容来得知。

### 类型声明

Java 和其它强类型的语言的一个重要特性是需要声明变量的类型。因为需要声明变量，所以声明过程也是一个沟通的机会。通过声明告知读者这个变量是用来干什么的，而不是怎么实现的。

List<Person> members = new ArrayList<Person>() 告诉我们 members 会想一个列表一样使用。所以我希望看到它调用 get() 和 set() 方法，因为列表和集合的区别是它可以按照顺序访问元素。

当我刚开始写这个模式的时候，我写得很武断。我曾认为所有变量都应该尽可能地声明地更一般性。但是我后来发现大多数变量并不值得这样做。有时候，我会把一个 List 类型的变量传给一个只接受集合类型的方法。这种声明的前后矛盾对读者而言更困惑，相比当用到 List 的时候没有确切声明。而更普遍的说法是：当需要的时候，尽可能地使用更一般的类型做声明。缺少一点点精确性和通用性来维持统一性是合理的代价。

更一般性的声明的好处是它提供了后期修改类的可能。如果我声明为 ArrayList，并不容易直接修改为 HashSet，但是如果我声明为 Collection 就可以。大体上说，声明得越精确，后期修改的灵活性就越差。为了维持灵活性，允许骚年的信息在传播。相比较 ”一个 Collection 里面的 members“，"ArrayList 里面的 members" 传播了更多的信息。

关注沟通性是一个很好的维持灵活性的启发式思考。类型声明就是一个例子。当我说变量保存了一个 Collection 我适当地表达。良好的的沟通提供了更好的灵活性。

### 初始化

在你开始编码之前，你需要知道你可以依靠什么。保持精确预测可以帮助你学到你需要知道的东西。一个对做预测有帮助的东西是变量的状态。初始化就是在程序启动之前给状态赋值的过程。

初始化变量时有一些问题。一个就是渴望初始化尽可能地声明。如果初始化和声明在一起，就一定有一个地方可以找到这个变量问题的答案。另外一个问题是性能。某些初始化代价很大的变量有时候需要初始化很多次。比如说，在 Eclipse 里面，类尽可能晚地加载来保证启动速度。

下面的是初始化的两个模式：eager 和 lazy

### 预初始化

一种初始化方式是在刚开始时就初始化变量--在它声明的地方或者对象创建的时候（声明过程和构造过程）。预初始化的好处是你可以假定变量在使用时都已经初始化好了。

如果可能，尽量在声明的时候初始化。这样可以将声明和实际的类型放在一起，便于读者理解：

	class Library{
	  List<Person> members = new ArrayList<Person>();
	}

如果不能在声明的时候初始化，就在构造器里面初始化：

	class Point {
	  int x, y;
	  Point(int x, int y){
	    this.x = x;
		this.y = y;
	  }
	}

初始化一个对象里面的所有属性要有一种对称性，都在声明语句或者都在构造器里面。然后，随着对象的变大，混合这两种类型也不会引起混淆。

### 懒初始化

预初始化在你不需要考虑计算一个变量的代价的时候很好用。当一个计算的代价很大时，你更喜欢将这种代价放到一个单独的 getter 方法里面，然后在第一次使用的时候来初始化：

	Library.Collection<Person> getMembers() {
	  if(members == null)
	    members = new ArrayList<Person>();
	  return members;
	}

懒初始化过去常常是一种更通用的技术。计算能力的限制很多时候是一个问题。懒初始化在计算资源是受限的时候非常重要。一个资源受限的环境，如 Eclipse， 启动必须足够快，使用懒初始化来当需要的时候来加载插件。

懒初始化的属性比预初始化的属性更难以理解。读者至少需要找两个地方才能理解属性的实现。但写代码时，你是在给以后的读者编写信息。幸运的是，只有很少的问题经常被提及，而回答大部分问题只需要说：这里性能更重要。

### 总结

状态模式谈论了如何在程序中展现一个状态。下一章节展现硬币的另外一面：如何更好地写出控制流程。













