## 第六章

### 概述

这一章重点介绍了如何来使用状态来达到沟通的目的。对象就是行为和状态的封装，一个是对外部世界的展现，一个是用来支持行为的。对象的一个优势是将程序的所有状态划分成一个个小块，每一个仅影响自己的那一部分计算逻辑。一堆状态混杂在一起，胡乱地引用，导致了代码的每处改动变得困难，因为状态的一点变化可能导致的影响无法预测。通过对象，我们就可以比较简单地分析一处代码改动可能的影响，因为状态的命名空间让这件事变得容易。

这章包含了以下模式：

+ 状态		---	根据时间计算变量的值
+ 限制使用	---	限制状态的使用来维持灵活性
+ 直接引用	---	在一个对象内部使用状态
+ 间接引用	---	通过方法来使用状态以保持更大的灵活性
+ 通用状态	---	将状态的共同部分存储到一个类的所有实例中
+ 多样状态	---	表示一个状态在不同对象之间的不同
+ 外部状态	---	代表特定对象的特殊目的状态
+ 变量		---	变量提供了使用状态的一个命名空间
+ 本地变量	---	本地变量保存了一小块作用域的状态
+ 属性		---	属性存储了一个对象整个生命周期中的状态
+ 参数		---	参数在调用方法时用于和状态沟通
+ 返回值参数	---	传递一个参数来保存多个方法的复杂结果
+ 参数对象	---	将频繁使用的参数列表封装成对象
+ 常量		---	表示像常量一样不会变化的状态
+ 角色相关名	---	根据计算中一个结果之后行为来命名变量
+ 声明类型	---	声明变量的一个类型
+ 初始化		---	尽可能根据声明来初始化变量
+ 预初始化	---	在创建实例时初始化属性
+ 懒初始化	---	在第一次使用时初始化属性


### 状态

世界一直存在，如果一分钟之前，太阳高高地挂在天空中，你可以确定现在它也在高空中，只不过移动了一点点。如果我仔细计算，我可以根据之前的观察预测它的新位置会在哪里，这需要地球自转的知识和过去这段时间的长短。

看清世界上事情发展的规律已经被证明是非常有帮助的。我住的地方的美国本土人士春天观察麦克洛克林山。当积雪慢慢融化，露出山峰的轮廓，就是到罗格河抓三文鱼的时候了。山上的雪的状态可以看出什么时候可以到附近去游泳了。

当先驱们在讨论计算机程序哲学的时候，它们确定了这种状态变更的规律。基于学习，人类大脑产生了许许多多不同的处理状态的策略。

然后，状态依然给程序员造成了许多麻烦。即使你给状态做了一个很小的假定，也可能让你的代码面临风险。你可能假定不正确，或者状态可能会变化。许多很棒的工具，比如说自动重构器，如果没有状态会更容易实现。最后，并发和状态在一起很难处理。如果没有状态的话，许多多线程问题都不存在了。

函数式语言完全移除了状态的变化。然后它们没有一个流行起来。我认为状态是一种很有价值的说法，因为我们的大脑是结构化的并且适应了处理状态变化的情况。单纯赋值或者无变量的程序让我们抛弃许多有效的策略。

面向对象语言是采用复制的方式来处理状态的。它们将状态切分为单独的小块，并且每块之间严格禁止访问，这样来避免了（被别人改变的）状态所带来的问题。相对于百万字节来说，跟踪记录少数几个字节相对更容易一些。对状态的不正确假定的问题依然存在，但是通过对象，你可以方便并且清楚地查看一个变量的所有引用。

管理状态的关键是将相似的状态放在一起，保证不同的状态分开。关于如何确定两个状态是一样的两个方法是：它们出现在同一个计算过程和它们同时产生同时消亡。如果两个状态一起使用，并且具有相同的生命周期，那将它们放在一起更好。

### 访问

不同程序语言的一种归类方法是访问已存储的变量的方式和调用计算过程的方式。这两个概念的相互理解的。访问内存就像调用函数来返回当前存储的值。调用函数就像读取上一次计算内容的的返回值在内存中的位置。尽管如此，程序语言还是可以根据调用计算过程和访问内存来划分，所以我们需要知道这两者之间有什么不同。

确定那些要存储，那些需要计算影响了程序的可读性，灵活性和性能。有时候这些是相互冲突的。有时候内容变化了，导致了昨天两者之间的很好的平衡又变得无效了。做出可用的决定并考虑之后可能的变化的灵活性是开发优秀软件的关键。考虑到未来可能的变化，在存储和计算之间取得清晰地平衡就很重要了。

对象的一个目的是管理存储。每个对象就像一个拥有自己的内存的小计算机，相互之间独立。当代语言，包括 Java，通过访问级别来隔离不同的对象。减少内部对象的访问并不值得丢失了对象之间的独立性。


### 直接访问

最简单的方式来取数据和存数据就是使用了直接变量访问。

	x = 10;

直接变量访问有表达式清晰的好处。当我看到 x＝10； 我很清楚这是要做什么。这种清晰也导致丧失了一些灵活性。如果我直接将一个值存在一个变量中，那我也不能做其它额外的东西了。如果我将一个值存储在那些程序其它部分会使用的变量中，然后它们会根据程序的不同发生变化。

直接访问的另外一个不好的地方是它是一个实现细节，层级比我们编程的大多数想法都要低。将一个变量设置为 1 可能会表示我的车库门被打开了，但是这种代码并没有太多的可读性。比较以下几种写法：

	doortgister = 1;   或者  openDoor();   或者  door.open();
	
我们在编程时候，大多数时候并不考虑具体存储。大量的直接访问会导致代码混乱，丧失可读性。对那些真正需要考虑存储的地方，我直接访问来实现我的想法。不同的程序对存储的要求不同，所以没有一个规则来适用任何人的情况。人们开始想出以下规则：只在设置方法或者构造器里面直接访问。直接访问只出现在一个类或者一个类及其父类或者在一个单独的包里面。没有普适的规则。程序员需要思考，沟通和学习。这是成为专业开发者的一部分。

### 间接访问

你可以隐藏访问并且在方法调用后面修改状态。这种设置方法在付出清晰性和直接的代价下获得了灵活性。客户端不再直接存储一个值。	这样，你就可以在不影响客户端的前提下修改存储实现。

我操作状态的一个基本策略是允许一个类中直接访问，客户端则采用间接访问。这个策略的好处是可以保证大多数时候修改状态是清晰和直接的。注意：如果对一个对象的大多数访问都是在对象外的，那可能隐藏着一个很深的设计隐患。

另外一种策略是只使用间接访问。我发现这样会导致丧失清晰性。大多数取值和设值方法是简单的。它们通常超过了大多数真正有用的方法，导致代码很难读。所有的取值和设值方法是临时的。大多数时候，我们并不去深究这个计算应该属于哪里，而是直接在某个地方实现，然后调用设置方法来存储状态。

一种明确使用间接访问的地方是两个相伴的数据。有时候这是很明显的，比如在缓存值中：

	Rectangle void setWidth(int width) {
	  this.width = width;
	  area = width * height;
	}

有时候却并不明显，在一个监听器中：

	Widget void setBorder(int width) {
	  this.width = width;
	  notifyListeners();
	}

这样的相伴数据是非常不好看的（很容易忘记维护这种关系）但是却是最好的选择。这种情况下，间接访问是最恰当的。


### 公共状态

很多计算使用这些相同的数据。如果你发现了这种计算过程，尝试在类中声明属性。比如说：所有计算笛卡尔点的地方都需要横坐标和纵坐标。因为所有点都需要这些值，它们可以更清晰地表示为：

	class Point {
	  int x;
	  int y;
	}
	
和直接使用状态变量相比，这种方式无疑更清晰可读。你的读者可能希望知道你的对象需要什么才能调用成功。公共状态可以让这个更清晰和恰当。

一个对象里面的公共状态应该有相同的作用域和生命周期。有时候我还被引导去使用一个单独的属性，或者说只有当某个方法计算之后才有效。这种情况下，我就知道应该去修改代码了，找到其它地方来存储数据，可能是一个参数或者一个帮助对象。


### 变量状态

有时候同样的对象根据使用情况的不同需要不同数据。它不仅仅是值不同，整个展现的形式都是不一样的。

变量状态常用于存储成 map 的形式，key用来作为元素的名字，值用来作为数据的值。

	class FlexibleObject {
	  Map<String, Object> properties = new HashMap<String, Object>();
	  Object getProperty(String key) {
	    return properties.get(key);
	  }
	  void setProperty(string key, Object value){
	    properties.set(key, value);
	  }
	}

变量状态比公共状态灵活一些。它主要的问题在于沟通性不够好。只有变量状态可以正常工作的函数如何在对象中展现呢？只有仔细阅读代码甚至于查看执行过程才能够帮助你回答这个问题。

我看到过有人过度使用变量状态的代码。每个对象都有几乎相同的属性对。我更希望直接使用属性声明来表示这些相同的东西。

一种情况下正适合变量状态的是一个属性的状态暗示了另外一个属性的需要。比如说：如果我有一个控件 bordered 标志为 true ，我就可以有 borderWidth 和 borderColor 。这时候，我可以使用变量状态，就像表 6.1 所示：

[Figure 6.1]()

公共状态也可以表示，就像表 6.1 下面的一样。

公共状态的解决方案违反了一个原则：对象中的所有变量应该具有相同的生命周期。多态提供了更清晰的解决方案。一种代表了无边的状态，另一种代表了有边的状态。Bordered 有公共状态代表它的参数。

[Figure 6.2]()
		  	
一些变量共用同一个前缀就代表了可能需要一个帮助对象。

尽可能地使用公共状态，在一个可能或者不可能依赖使用情况的属性上使用变量状态。

### 外部状态

有时候你的程序需要一个状态，但是系统的其他部分并不需要。比如说：对象存储在哪里是持久化机制关心的，但是其它部分并不关心。将这些数据存在属性里面会破坏对称原则。所有其它属性是整个系统需要的。

保存一个对象相关的状态在靠近使用的地方，而不是对象属性上。持久化机制将维护一个 IdentityMap 它的key是要保存的对象，value是保存地址的信息。

外部对象一个薄弱之处在于它使得拷贝对象变得困难。复制一个包含外部状态的对象不仅仅是复制它的属性。而是，所有和它相关的外部对象都需要正确地复制，这取决于具体的情况。常规的检查并不会检测一个对象关联的所有数据。因为这些麻烦，外部状态很少使用，除非必要。

### 变量

在 Java 里面，对象是根据变量来指向的。读者需要知道作用域，生命周期，角色和变量在运行时的类型。因为我们已经有根据变量交流的整套的方法，所以用简单的变量名来简化代码是非常棒的。

变量的作用域，变量能够被引用到的范围，可以有三种类型：本地的，当前作用域可见；属性，可以在一个对象的任何地方可见；静态的；所有类和对象可见。属性的作用域可以根据 public, package, protected 和 private 修改

如果你作用域限制比较宽松，那就意味着从名字清晰地看出它们之间的区别就很重要。然后，为了减少伴随现象，你最好尽量使用临时变量和属性，偶尔使用静态变量和私有作用域的修改。通过使用这种限制，你就告诉读者他们看到的是临时变量还是属性。如果有声明，那就是临时变量，否则就是属性。这估计需要在变量里面包含作用域信息。作为回报，你就拥有了可控地，易读的变量名。所有这些的前提是你可以将你的代码切分成小块，这是你可以用来实现模式的能力，尤其是组合方法。

变量的生命周期可以比它们的作用域短。属性可以仅在某些方法触发后有效。但这是很丑陋的。努力使得变量的生命周期和它们的作用域相当。进一步地，保证它们的兄弟变量拥有同样的生命周期。

变量类型是一个可以通过类型声明来达到充分沟通的目的。保证声明类型可以尽可能清晰地沟通。这个建议的一个例外是当变量的名字拥有多个值时（可能包含了一个集合），可能是多元的。单值和多值变量的区别对与读者来说很重要。

通过作用域，生命周期和类型，名字可以用来达到沟通的目的。通过减少需要表达的信息，我们可以尽可能地简化名字。

### 临时变量

临时变量仅从声明开始到他们的作用域结束之间可以访问。遵循信息应该尽可能少地传播的原则，临时变量应该在将要使用时声明并且尽可能地在最深的作用域。

这里有一堆临时变量的角色：

+ 集合：用来保存之后可能使用的信息。通常这种类型是以结果的形式返回的。可以用 result 或者 results 命名。
+ 计数：一个特殊的集合，用来保存其它对象的数量。
+ 解释：如果你有一个巨复杂的表达式，将每一部分赋给一个临时变量有助于帮助读者理解。

	int top=...;
	int left=...;
	int height=...;
	int bottom=...;
	return new Rectangle(top, left, height, eidth);
	
即使不需要计算，解释用的临时变量也对长长的，复杂的表达式有帮助。

解释临时变量经常意味着需要帮助方法。表达式就是方法体，临时变量则是方法名。有时候这样可以用来简化方法调用，有时候又可以用来移除重复表达式。

+ 重用：当一个表达式的值变了，但是你又想多次使用相同的值，可以将它保存在临时变量中。比如说：如果多个对象需要相同的时间戳，你不能每次获取最新时间：

	for(Clock each: getClocks())
		each.setTime(System.currentTimeMillis());
	
而使用临时变量来保存时间而达到目的：
	
	long now=System.currentTimeMillis();
	for(Clock each: grtClocks())
		each.setTime(now);	

+ 元素：最后一个临时变量的用法是保存一个集合中的当个元素。在上面的例子中，each 是清晰、简单的名字。如果你要问“each what？”，可以看一看 for 语句。

对于嵌套循环，将集合的名字加到临时变量的最后来区分：

	broadcast() {
		for (Source eachSender: getSenders())
			for(Destination eachReceiver: getReceivers())
				...;
	}

### 属性

属性的作用域和生命周期和它附属的对象是一致的。因为属性主要是用于对象，不管是在类的开始还是最后声明。在最前面声明，可以帮助读者更好地阅读剩下的代码。在最后面声明则表示：“逻辑为王，数据只是实现细节”。尽管我同意在对象编程中逻辑要比数据重要，我依然喜欢先看声明语句，在阅读剩下的代码。

你还可以将属性声明为 final。这就告诉读者，运行期间这个属性的值不会改变。当我在不确定属性会不会变时，我不会明确声明属性（是不是 final）。这个额外获得的清晰性并不值得所带来的额外复杂性，但是如果我的代码可能以后被其他人修改，最好还是搞清楚要不要使用 final。

以下属性的作用并没有临时变量的那么全面。尽管如此，下面是属性的一些公共作用：

+ 帮助：帮助属性保存被多个方法使用的对象的引用。如果一个对象被多个方法使用，考虑用帮助属性代替。

+ 标志：布尔型的属性表示：这个对象有两种模式。如果这个标志还有一个设值方法，那就代表了：这个对象的行为在其生命周期里可能发生变化。在特定条件下使用标志属性是挺好的。如果代码需要基于拷贝的标志做决定，考虑使用策略属性。

+ 策略：当你需要需要选择如何表现某一部分计算过程，将计算的结果保存在一个属性当中。如果这种变化在一个对象的生命周期都不出现，就在对象构造函数中设置，否则，就提供方法来改变。

+ 状态：当对象代理时，状态属性和策络属性很像。然而，状态属性，调用时会自己设置状态。策略属性则通常是别的对象来修改。状态机的实现是非常难读的，因为状态和过渡不在一起。但是对于简单的状态机，它就足够了。

+ 组合：这种属性保存对象所拥有的数据和其它对象引用。

### 参数

除了非私有变量（属性和静态属性），对象间沟通的方式就是传递参数。因为非私有参数表明了类之间的强伴随关系，并且这种关系会随着时间逐步变得更强，在静态属性和参数都可以使用的情况下，参数是更好的选择。

单个参数的伴随现象比对象之间的引用的伴随想象要轻微得多。比如说：在树结构内部的计算通常需要知道一个节点的父节点。相对于直接保存一个父节点的引用，传递参数所带来的影响要小得多。当父节点没有引用时，他就可能有多个树的子树。

[Figure 6.3]()

如果一个对象到另一个对象的许多消息都需要相同的参数，最好将对象的引用作为参数。参数是捆绑在对象上的轻型线程，就像格列佛和小人国一样，但是足够多的参数也可能导致对象难以改变。

[Figure 6.4]()

假如一段这样的代码：

	Server s = new Server();
	s.a(this);
	
变成了这样的：
	
	Server s = new Server();
	s.a(this);
	s.b(this);
	s.c(this);
	s.d(this);
	s.e(this);

这是，你如果改用引用，就更简单一点。

	Server s = new Server(this);
	s.a();
	s.b();
	s.c();
	s.d();
	s.e();
	
### 集合参数

		
	


















