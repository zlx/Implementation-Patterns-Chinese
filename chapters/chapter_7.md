## 行为

冯.诺依曼 提出了计算的主要特点--指令应该一句一句地执行。这种特性贯穿在大多数语言当中，包括 Java。这一章节将介绍如何来表示程序的行为。这些模式有：

+ 控制流程 --- 表示一系列步骤的计算
+ 主流程   --- 清晰地表达主控制流程
+ 消息	--- 通过发送消息来表示控制流程
+ 选择消息 --- 用不同的消息来表达不同的选择
+ 两次分发 --- 在两个轴之间实现不同的消息来表示连续的选择
+ 分解消息 --- 将复杂的计算分解为合理的小块
+ 反转消息 --- 通过传递一系列消息到相同的接收器来保证控制流程的对称性
+ 邀请消息 --- 通过发送一个可能被不同方式实现的消息来适应未来的变化
+ 说明消息 --- 发送一个消息来说明一堆复杂逻辑的目的
+ 异常流程 --- 尽可能在不干涉主流程的情况下清晰地表达不常用的流程
+ 警卫条款 --- 通过一个提早返回值来表达临时的异常流程
+ 异常    --- 通过异常来表示非临时异常流程
+ 可检查异常 -- 确保这些明确声明的异常都被捕获
+ 传播异常 --- 根据需要来传播，转化异常，来保证接受者可以获得这些信息

### 控制流程

为什么我们的程序里面需要控制流程？某些程序语言，如 Prolog 里面没有明确的控制流程的概念。逻辑飘浮在那里，等待正确的条件来激活。

Java 那种把控制流程作为基本组成原则的语言家族的一员。相邻的语句一句接着一句执行。条件语句则用来保证语句在某些情况下执行。循环用来重复执行代码。消息用来激活子程序。异常捕获机制则用来跳出堆栈。

所有这些机制都是用来丰富在执行计算这个过程的。作为一个作家/程序员，你决定如何组织你脑海中的流程，包括一个包含异常的主流程和许多个看上去很重要的子流程或者它们的混合体。你将一些控制流程打包来抽象，对于细致的读者，才需要理解它们来知道更具体的细节。一些抽象是常规的，一些这是代理到其它对象的。

### 主流程

程序员脑海中都会有一个主流程。进程从这里开始，到这里结束。这条路上可能会有其它决定或者异常，但是都有计算路径。使用你的程序语言来清晰表达这个。

有些程序，可能被设计成恶意的情况下工作，就不容易出现主流程。然而，这种程序是少数。用你的程序语言的表达力来清晰表示那些很少被执行，很少变化的部分和高度重要的部分：那些被经常阅读，理解和修改的部分。这不是说异常条件不重要，专注于清晰表达主流程更加容易有回报。

因此，清晰表示你的程序的主流程。使用异常和警告条款来表示不正常或者错误条件。

### 消息

在 Java 中，表达逻辑的一个主要含义就是消息。程序语言使用程序调用作为一种信息隐藏机制。

	compute() {
	  input();
	  process();
	  output();
	}

也就是说：为了理解计算过程，你只需要知道她有三个步骤就够了，这时候，细节是不重要的。面向对象编程的一个优美之处是同样的处理过程可以表达更丰富的信息。对于每个方法，可以有相同的结构，而不同的实现细节。所以，对你来说，当你专注于不变的东西时，就不需要关注以后有可能发生变化的部分。

使用消息作为控制流程的基本元素就意味着修改就是程序的基本状态。每个消息都可能是一种可能，尽管发送者不变，接收者都可能发生变化。也就是说：那里有些东西，它们的细节并不重要。基于消息的程序就是说：这时，某些部分感兴趣的消息出现了，细节则可能是多变的。明智地使用这种灵活性，可以清晰和直接地表示那些细节可能会变化的逻辑。如果你想你的代码根据沟通性，这就是一种很重要的技能。

### 选择消息

有时候我发送一个消息来选择实现，就像程序语言上面的开关语句。比如说，我需要以不同的方式来显示图形，我会发送一个多态的消息，而在运行时决定如何实现。

	public void displayShape(Shape subject, Brush brush) {
	  brush.display(subject);
	}

消息 display() 根据运行时的 brush 类型来选择实现。这样，我就可以自由地实现多种 brush： ScreenBrush PostscriptBrush 等。

使用选择消息可以让我们进行抽象编程。每种选择消息都是一种对未来扩展的友好形式。你的程序中每个明确的条件都是下次行为变更时需要明确修改的地方。

阅读运用大量选择消息的代码是一种需要学习的技能。选择消息的代价是读者需要跨越很多个类才能理解计算的细节。作为一个作者，你可以给每个方法取一个友好而明确的名字来帮助读者理解。另外，明确知道什么时候使用选择消息是过度的。如果计算中不可能出现多种情况，就不需要让其支持多样性。

### 两次分发

选择消息是一种处理单纬度多样性的好办法。在选择消息的例子里，多样的纬度是需要画的形状类型是那种。如果你需要表示两个个相互独立的纬度的多样性，你可以使用连续使用两次选择消息。

比如说：假如我想表示 Postscript 椭圆和 Screen 矩形的区别。首先，我们需要决定将这个计算放在哪里。基本的计算看上去属于 Brush，所以我首先发送一个选择消息给 Shape，然后给 Brush：

	displayShape(Shape subject, Brush brush) {
	  shape.displayWith(brush);
	}

这样，每个 Shape 都可以实现一个不同的 displayWith()。不需要做任何细节的工作，它们就可以将它们的类型信息发送给 Brush。

	Oval.displayWith(Brush brush) {
	  brush.displayOval(this);
	}

	Rectangle.displayWith(Brush brush) {
	  brush.displayRetangle(this);
	}

这样不同类型的 Brush 就可以得到它们需要的信息了。

	PostscriptBrush.displayWith(Rectangle subject) {
	  writer print(subject.left() + "" +...+ " rest);
	}

两次分发介绍了某些丢失灵活性的做法。第一个选择消息的接受者的类型调用第二次选择消息的接受者作为方法。在这个例子中，意味着，添加新 Shape，需要给每个 Brushes  添加方法。如果某个纬度比另一个变化更频繁。就让它作为第二个选择消息的接受者。

我的计算机科学理念让我概括出三次，四次甚至五次分发的情况。然后，我只碰到一次三步分发的情况，它不是常态。我总是能找到更清晰的方式来表示多维度的逻辑。

### 分解（一系列）消息

如果你有一个包含多个步骤的复杂消息，有时候，你可以将某些相关的消息分组然后调用它们。这类消息并不是为了提供一个专有化的或者世故的钩子。这仅仅是一种过时的程序性分解。这个消息就是常规的调用子步骤。

分解消息需要一个好名字。很多读者都能够将同样目的的子句集中在一起独立出来。只有那些需要知道实现细节的人才需要阅读分解后的消息细节。

分解消息时可以取不同的名字可能意味着这时候不应该这么分解。另外一个信号是很长的参数列表。如果我看到这个信号，我会内联这个分解消息的方法然后使用其它模式，比如说，方法对象，来帮助我组织程序。

### 反转消息

对称性能够增加代码的可读性。比如下面的代码：

	void compute() {
	  input();
	  helper.process(this);
	  output();
	}

因为这个方法由三个其它的东西组成，所以它不是对称的。提高可读性的方法是介绍一个帮助方法来实现潜在的对称性。当阅读 compute() 这个方法的时候，我没有关注谁发送了消息--它们都是 this。

	void process(Helper helper) {
	  helper.process(this);
	}

	void compute() {
	  input();
	  process(helper);
	  output();
	}

那读者就可以通过单个类就知道 compute() 是如何组织的啦。

有时候通过调用相反的消息的帮助方法比在自身上调用更重要。有时候，过度使用反转消息会让方法变得异常难以理解。比如我们有下列代码：

	void input(Helper helper) {
	  helper.input(this);
	}

	void output(Helper helper) {
	  helper.output(this);
	}

最好的方式是将整个 compute() 移到帮助类中：

	compute() {
	  new Helper(this).compute();
	}

	Helper.compute() {
	  input();
	  process();
	  output();
	}

有时候我感觉单纯为了审美需求，比如说对称性，去修改方法是很愚蠢的。审美帮助它走的更远。美的东西比单纯的线性的逻辑能引发你的大脑更多的思考。一旦你的大脑习惯了优美的代码，你就可以从你的代码中得到更多关于代码质量的信息。这种感觉能够帮助你从语法层找到明确的名字和恰当的模式。

### 邀请消息

有时候你写代码时，希望别人能够在子类中实现一些计算。发送一个合适的具名消息来保持以后的精炼可能性。这个消息让程序员以后能够根据需要精炼计算。

如果这个逻辑有默认实现，让它变成这个消息的一个实现。如果没有，声明这个方法是抽象的来表示需要实现。

### 解释消息

意图和实现之间的距离在软件开发当中往往是很重要的。这就是说你可以先理解计算的本质，然后如果有需要的话，理解细节。你可以通过在解决问题的时候发送消息而不是解决完问题发送消息来缩短这个距离。

我看到的第一个这样的例子是在 Smalltalk 。音译过来，这个方法就是这样的：

	highlight(Retangle area) {
	  reverse(area);
	}

我想，这个方法有什么用，为什么不直接调用 reverse() 而调用 highlight() 方法。后来，我明白了，highlight() 并没有计算目的，它只是起到了一个解释意图的作用。调用方法应该解释我们想要解决的问题，比如说给屏幕高亮。

如果你需要给一行代码做一个解释，考虑使用解释消息代替。比如说：

	flags |= LOADED_BIT;  // set the loaded bit

我更喜欢看到

	setLoadedFlag();

尽管 setLoadedFlag() 的实现很小，单行的方法是用来沟通的。

	void setLoadedFlag() {
	  flags |= LOADED_BIT;
	}

有时候解释消息的帮助方法变成以后扩展的重要部分。这是很棒的事情。然而，对我来说，调用解释消息的主要目的是用来解释意图。

### 异常流程

就像程序有主流程，它们也有一个或多个异常流程。有一些计算路径是较少被执行，较少会修改，相比主流程而言不重要一些的，它们的沟通要求就会低一些。清晰地表达主流程，然后保证这些异常流程尽可能不要复杂化主流程。警卫条款和异常是表达异常流程的两种方式：

如果程序语句都是一句接着一句执行，那会比较易懂。读者可以使用舒服和熟悉的阅读散文的方式来理解代码的意图。有时候，程序会有多条执行路径。将所有路径都同等看待会导致很多问题，在这里设置标志，另外一个地方使用，并且返回值都有特殊的含义。回答这个基本问题：“执行了什么状态？”变成了考古学和逻辑学的混合体。抓住主流程，清晰表达它，然后使用异常来表达其它路径。











