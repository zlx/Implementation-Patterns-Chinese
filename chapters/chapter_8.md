## 方法

逻辑被划分为方法，而不是混杂在一块。为什么呢？什么样的程序能够通过引出一些新的代码快来解决呢？为什么需要方法？理论上说，你可以用一大块代码之间的跳转来组织你的程序。这就是早期程序的组织方式，一整块代码逻辑团。这样最大的问题是难以阅读。很难区分那部分是重要的，那部分相对不那么重要。很难区分那些是方法调用的，当需要修改功能时那些是重要的。第二个问题是大多数程序中的问题并不是独一无二的。不需要每次都重新实现一遍，我们可以调用原先的实现。这种巨大模块的方式为以后复用造成了困难。

将程序逻辑划分为一个个方法就是说：“这块逻辑可以随时调用。”将不同的方法划分为不同的类会更好一些。将这段代码放在这个方法，另外一段代码放到另外一个方法就是说这两块内容暂时没有联系。他们可以分开理解和阅读。另外，方法的名字给了你一个和读者沟通的机会，告诉读者这段计算的意图。读者可以通过阅读名字就知道方法的含义。

方法能够解决重用的问题。当你在写一个新的内容的时候需要一大块以前某个方法里实现过的逻辑，你可以直接调用那个方法。

将巨大的计算切分成方法理论上很简单：只需要将相关的代码放在一起，不相关的代码很离开。实际上，你需要话费巨大的精力来区分出那些代码应该在一起，那些又不是，然后怎么样做最好的切分。目前的最好的切分并不意味着之后这样也是对的。这种切分应该能够减少你的总的工作量。需要经验才能知道怎么样的切分最好。这里有一些我的经验。

切分程序为一个个方法最常见的问题是方法的大小，目的和命名。如果你制造了太多过小的方法，读者就需要大量的精力来跟踪你的碎片化的表达方式。过少的方法则会导致重复和缺乏灵活性。编程中有许多陈词滥调，创建一个新方法是完成许多工作的途径。解决这些问题的方法是很容易命名的。给解决特定问题的方法命名是比较困难的，但是对读者而言很重要。

下面是方法相关的模式：

+ 组合方法		--- 组合成其它方法
+ 意图命名		---	用方法的意图命名
+ 方法可见		---	尽可能使方法私有化
+ 方法对象		---	将复杂的方法变成对象
+ 重载方法  	---	重载方法来实现特殊的用途
+ 方法超载  	---	给同一个计算提供多种实现选择
+ 方法返回值    ---	声明最常用的方法返回值
+ 方法注释  	---  给方法写注释来说明不容易从代码里面看出来的信息
+ 帮助方法  	---  用私有的小方法来简洁地表达主计算过程
+ 调试信息  	---  使用 toString() 来输出有用的调试信息
+ 转换    	 ---  清晰地实现一种类型到另一种类型的转换
+ 转换方法 		---  对于简单，有限的几个转换，直接在原对象上提供方法来返回对应的转换后类型
+ 转换构造器    ---  对于大多数转换方法，再转换后的方法里面提供一个可以接受原对象作为参数的方法
+ 创造器 		---  清晰地表达对象创造器
+ 完全构造器	   ---  写出能够返回完整对象的构造器
+ 工厂方法	    ---  使用静态方法来代替构造器来表达复杂的创造器
+ 内部工厂	    ---  将对象创造器压缩到一个帮助方法里面去来方便以后修改或者精简
+ 集合访问方法   ---  提供对集合的有限几个操作
+ 方法的布尔设置 ---  如果有利于沟通，为不同的状态提供不同的方法来设置布尔值
+ 查询方法	    ---  以 asXXX 为名字的返回布尔值的方法
+ 判等方法	    ---  同时定义 equals() 和 hashCode() 方法
+ 取值方法	    ---  提供一个可以获取一个属性的值的方法
+ 设值方法	    ---  使用一个方法来设置一个属性的值
+ 安全拷贝	    ---  拷贝对象的进出访问方法来避免出现别名错误

###  组合方法

调用其他方法来组合方法，组合的每个方法都要求在同一抽象级别。

一种不好的组合方法是混合了不同的抽象层次：

	void compute() {
	  input();
	  flags ||= 0x0080;
	  output();
	}

像这样的代码是非常刺耳的。当代码流畅的时候更容易读懂，突然的改变抽象级别会破坏这种流畅感。中间那个位操作是干什么的？当我读到上面的代码时我会询问自己。它代表什么含义？

反对使用大量的小方法是对于性能的考虑：因为调用方法会带来性能开销。我写到这里的时候做个一个性能测试，比较一百万个循环和一百万个消息，平均增加 20-30% 的开销，不足以影响大部分程序的性能。更快的 CPU 和性能瓶颈强烈的局部特性使得代码性能直到数据达到一定量级时才是需要考虑的问题。

一个方法应该有多大？有些人建议限制行数，比如说限制在 5 - 15 行。它可能是正确的，因为大多数可读的代码都满足这个限制，限制引发出一个问题“为什么？”为什么当这么大小时逻辑能够表达得最好呢？

代码读者需要解决许多问题来避免方法大小的影响。当阅读总体框架时，看到大量代码是有价值的。方法中的空格提供了总体框架和代码复杂性的线索。那些是条件表达式和循环吗？这个控制语句有多深的嵌套？方法名字暗示了方法完成了那些工作？

当我试图理解代码细节时，原先适应了的相同的大方法会变成一个阻碍。我们大脑一次只能保留一个思路，一个上千行的方法包含了不止一个思路。为了理解细节，我想将相关的细节放在一起，不相关的分离开。

同时支持浏览和消化对代码作者，切分逻辑到小方法的人，来说是一个挑战。我发现，当我把方法拆分成小方法时，它们变得更容易理解了。当我有一些相当独立的细节被之后变成支持方法时，诡计就被识破了。有时候，我们有很多容易理解但是不容易切分的细节。那种情况下，我就会创建一个方法对象来组织这些细节。

另外一个选择方法大小的问题是专业化。合适大小的方法可以被整个重新实现而不需要把代码拷贝到子类来做修改。

组合方法基于现实而不是猜测。先让你的代码可以工作，然后思考怎么组织。如果你在实现前花了大量的时间来思考如何组织代码，那有可能在实现过程中会重复做这个工作。当所有的细节放在我面前，这样更容组合方法。有时候，我认为我知道方法应该如何组合，但是当我做好逻辑划分时，我发现这样很难阅读。这时候，我发现我将这些方法内联会比较好，直到有一个巨大的方法也需要重新切分。

### 意图化命名

方法应该被命名为潜在调用者使用方法时的意图。还有另外一些你想在名字里表达的信息--比如说：实现策略。然而，用名字来表达意图，用其他方式来表达其他信息。

实现策略是经常出现在方法名里面的额外信息。比如说：

	Customer.linearCustomerSearch(String id)

改成下面这种会更好：

	Customer.find(String id)

因为前一种不仅仅表达了这个方法的意图。然而，代码作者的目标不仅仅是让你尽快直到你能用这个方法干什么。有时候需要克制自己。除非实现策略对读者是非常重要的，否则就不要出现在名字里面。好奇的人可以查看源码来了解实现细节。即使 Customer 提供了 linear 和 hashed 查找方法，最好在调用者的视角来对名字进行区分：

	Customer.find(String id)
	Customer.fasterFind(String id)

（实际上，这种情况下，最好只提供一个方法 find() 来满足所有用户，但那时另外一件事了。）不管这个更快的 find() 是使用哈希表还是树实现的，对用户来说，都不是非常重要。

想像方法名都是基于调用者调用时的意图来命名的。那就是读者最喜欢碰到的名字。为什么要调用这个方法而不是另外一个？这个问题最好能直接用方法名来回答。调用方法应该是讲述一个故事。合理的命名方法来更好的表达这个故事。

如果你类推到现有接口，给你的方法和接口一样的名字。如果你有一种特殊的迭代器，即使你不熟悉迭代器接口的实现，也可以调用 hashNext() 和 next()。如果你的方法是相识的，首先考虑是不是真的要这么用？然后想办法通过一些前缀来表示区别。

### 方法可见








