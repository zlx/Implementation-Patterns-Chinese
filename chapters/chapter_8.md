## 方法

逻辑被划分为方法，而不是混杂在一块。为什么呢？什么样的程序能够通过引出一些新的代码快来解决呢？为什么需要方法？理论上说，你可以用一大块代码之间的跳转来组织你的程序。这就是早期程序的组织方式，一整块代码逻辑团。这样最大的问题是难以阅读。很难区分那部分是重要的，那部分相对不那么重要。很难区分那些是方法调用的，当需要修改功能时那些是重要的。第二个问题是大多数程序中的问题并不是独一无二的。不需要每次都重新实现一遍，我们可以调用原先的实现。这种巨大模块的方式为以后复用造成了困难。

将程序逻辑划分为一个个方法就是说：“这块逻辑可以随时调用。”将不同的方法划分为不同的类会更好一些。将这段代码放在这个方法，另外一段代码放到另外一个方法就是说这两块内容暂时没有联系。他们可以分开理解和阅读。另外，方法的名字给了你一个和读者沟通的机会，告诉读者这段计算的意图。读者可以通过阅读名字就知道方法的含义。

方法能够解决重用的问题。当你在写一个新的内容的时候需要一大块以前某个方法里实现过的逻辑，你可以直接调用那个方法。

将巨大的计算切分成方法理论上很简单：只需要将相关的代码放在一起，不相关的代码很离开。实际上，你需要话费巨大的精力来区分出那些代码应该在一起，那些又不是，然后怎么样做最好的切分。目前的最好的切分并不意味着之后这样也是对的。这种切分应该能够减少你的总的工作量。需要经验才能知道怎么样的切分最好。这里有一些我的经验。

切分程序为一个个方法最常见的问题是方法的大小，目的和命名。如果你制造了太多过小的方法，读者就需要大量的精力来跟踪你的碎片化的表达方式。过少的方法则会导致重复和缺乏灵活性。编程中有许多陈词滥调，创建一个新方法是完成许多工作的途径。解决这些问题的方法是很容易命名的。给解决特定问题的方法命名是比较困难的，但是对读者而言很重要。

下面是方法相关的模式：

+ 组合方法		--- 组合成其它方法
+ 意图命名		---	用方法的意图命名
+ 方法可见		---	尽可能使方法私有化
+ 方法对象		---	将复杂的方法变成对象
+ 重载方法  	---	重载方法来实现特殊的用途
+ 方法超载  	---	给同一个计算提供多种实现选择
+ 方法返回值    ---	声明最常用的方法返回值
+ 方法注释  	---  给方法写注释来说明不容易从代码里面看出来的信息
+ 帮助方法  	---  用私有的小方法来简洁地表达主计算过程
+ 调试信息  	---  使用 toString() 来输出有用的调试信息
+ 转换    	 ---  清晰地实现一种类型到另一种类型的转换
+ 转换方法 		---  对于简单，有限的几个转换，直接在原对象上提供方法来返回对应的转换后类型
+ 转换构造器    ---  对于大多数转换方法，再转换后的方法里面提供一个可以接受原对象作为参数的方法
+ 创造器 		---  清晰地表达对象创造器
+ 完全构造器	   ---  写出能够返回完整对象的构造器
+ 工厂方法	    ---  使用静态方法来代替构造器来表达复杂的创造器
+ 内部工厂	    ---  将对象创造器压缩到一个帮助方法里面去来方便以后修改或者精简
+ 集合访问方法   ---  提供对集合的有限几个操作
+ 方法的布尔设置 ---  如果有利于沟通，为不同的状态提供不同的方法来设置布尔值
+ 查询方法	    ---  以 asXXX 为名字的返回布尔值的方法
+ 判等方法	    ---  同时定义 equals() 和 hashCode() 方法
+ 取值方法	    ---  提供一个可以获取一个属性的值的方法
+ 设值方法	    ---  使用一个方法来设置一个属性的值
+ 安全拷贝	    ---  拷贝对象的进出访问方法来避免出现别名错误

###  组合方法

调用其他方法来组合方法，组合的每个方法都要求在同一抽象级别。

一种不好的组合方法是混合了不同的抽象层次：

	void compute() {
	  input();
	  flags ||= 0x0080;
	  output();
	}

像这样的代码是非常刺耳的。当代码流畅的时候更容易读懂，突然的改变抽象级别会破坏这种流畅感。中间那个位操作是干什么的？当我读到上面的代码时我会询问自己。它代表什么含义？

反对使用大量的小方法是对于性能的考虑：因为调用方法会带来性能开销。我写到这里的时候做个一个性能测试，比较一百万个循环和一百万个消息，平均增加 20-30% 的开销，不足以影响大部分程序的性能。更快的 CPU 和性能瓶颈强烈的局部特性使得代码性能直到数据达到一定量级时才是需要考虑的问题。

一个方法应该有多大？有些人建议限制行数，比如说限制在 5 - 15 行。它可能是正确的，因为大多数可读的代码都满足这个限制，限制引发出一个问题“为什么？”为什么当这么大小时逻辑能够表达得最好呢？

代码读者需要解决许多问题来避免方法大小的影响。当阅读总体框架时，看到大量代码是有价值的。方法中的空格提供了总体框架和代码复杂性的线索。那些是条件表达式和循环吗？这个控制语句有多深的嵌套？方法名字暗示了方法完成了那些工作？

当我试图理解代码细节时，原先适应了的相同的大方法会变成一个阻碍。我们大脑一次只能保留一个思路，一个上千行的方法包含了不止一个思路。为了理解细节，我想将相关的细节放在一起，不相关的分离开。

同时支持浏览和消化对代码作者，切分逻辑到小方法的人，来说是一个挑战。我发现，当我把方法拆分成小方法时，它们变得更容易理解了。当我有一些相当独立的细节被之后变成支持方法时，诡计就被识破了。有时候，我们有很多容易理解但是不容易切分的细节。那种情况下，我就会创建一个方法对象来组织这些细节。

另外一个选择方法大小的问题是专业化。合适大小的方法可以被整个重新实现而不需要把代码拷贝到子类来做修改。

组合方法基于现实而不是猜测。先让你的代码可以工作，然后思考怎么组织。如果你在实现前花了大量的时间来思考如何组织代码，那有可能在实现过程中会重复做这个工作。当所有的细节放在我面前，这样更容组合方法。有时候，我认为我知道方法应该如何组合，但是当我做好逻辑划分时，我发现这样很难阅读。这时候，我发现我将这些方法内联会比较好，直到有一个巨大的方法也需要重新切分。

### 意图化命名

方法应该被命名为潜在调用者使用方法时的意图。还有另外一些你想在名字里表达的信息--比如说：实现策略。然而，用名字来表达意图，用其他方式来表达其他信息。

实现策略是经常出现在方法名里面的额外信息。比如说：

	Customer.linearCustomerSearch(String id)

改成下面这种会更好：

	Customer.find(String id)

因为前一种不仅仅表达了这个方法的意图。然而，代码作者的目标不仅仅是让你尽快直到你能用这个方法干什么。有时候需要克制自己。除非实现策略对读者是非常重要的，否则就不要出现在名字里面。好奇的人可以查看源码来了解实现细节。即使 Customer 提供了 linear 和 hashed 查找方法，最好在调用者的视角来对名字进行区分：

	Customer.find(String id)
	Customer.fasterFind(String id)

（实际上，这种情况下，最好只提供一个方法 find() 来满足所有用户，但那时另外一件事了。）不管这个更快的 find() 是使用哈希表还是树实现的，对用户来说，都不是非常重要。

想像方法名都是基于调用者调用时的意图来命名的。那就是读者最喜欢碰到的名字。为什么要调用这个方法而不是另外一个？这个问题最好能直接用方法名来回答。调用方法应该是讲述一个故事。合理的命名方法来更好的表达这个故事。

如果你类推到现有接口，给你的方法和接口一样的名字。如果你有一种特殊的迭代器，即使你不熟悉迭代器接口的实现，也可以调用 hashNext() 和 next()。如果你的方法是相识的，首先考虑是不是真的要这么用？然后想办法通过一些前缀来表示区别。

### 方法可见

四个等级的可见性---全局可见，包可见，保护，私有---每一种都表达了不一样的意图。

方法可见性的两个巨大的冲突是一些方法要求暴露给用户，同时又想保持未来的灵活性。越多的方法暴露出去，需要修改接口的时候就越困难。在开发 JUnit 的时候，Erich Gramma 和我进场在方法可见性上有分歧。我的 Smalltalk 背景建议让方法可见，可能对用户有帮助。Erich 的 Eclipse 经验告诉他灵活性来自于尽可能少地暴露方法。我慢慢地转向了他的观点。

选择可见性时，你有两个代价需要权衡。一个是未来的灵活性。暴露尽可能少的接口可以使未来的修改更容易。另外一个代价是调用代价。过少的接口导致客户端需要多做额外的工作来达到目的。权衡这两个代价来做出更好的可见性的决定。

我的一般策略是尽可能地限制访问。如果仅仅是挑选可见性，那可不难。一个工具可以指派方法的可见性。当你不具备某些知识时，真正的挑战就出现了，比如说一些不在你意料之中的代码开始调用你的方法。这时候，你就需要推断，决定哪些方法应该改成 Public 或者 Protected，这有可能导致你需要付出巨大的代价来修改。

+ Public： 当你声明一个方式是 Public 的时候，你就是说这个方法在定义它的包以外也是有用的。把一个方法设置为 Public 就代表了你接受了维护他的责任：永远不修改或者当你修改时改变所有调用的地方或者起码通知调用它的程序。

	public Object next();
这表示了从现在开始以及可预见的未来， next() 方法将对客户可见。

+ Package： 包可见是指这个方法在这个包里面的其它对象是有用的，但是你不想把它变成包外面的其它对象可以访问。这是一种古怪的状态--只有我的对象需要，不是所有对象都需要。把包可见的方法作为一种建议：要么部分功能应该移走，来保持这个方法可见性更小，要么这个方法应该更广泛使用，值得为他付出维护的代价。

+ Protected： 受保护这种可见性只在需要提供只在子类里面可见的方法时有用。看上去它比包可见更加严格，实际上这两种是正交的，因为包外面的子类也可以调用包里面的保护方法。

+ Private： 私有方法是保持未来灵活性的终极方式，因为你可以找到所有调用者，并且修改它们，不管外部使用者是调用还是继承你的代码。将一个方法设为私有，你的意思就是这个方法的返回值并不值得将它设为更大的可见性所要付出的代价。

慢慢地揭示出方法，从最严格的可见性开始，根据需要一点一点揭示出可见性。如果一个方法再也不需要目前的可见性，尝试降低它的可见性。降低可见性只有在你可以控制所有调用你的代码的地方，这样才能保证不会破坏其他依赖于这个方法可见性的代码。我常常发现，当我以一种新方式来使用一个对象的时候原先我认为私有的方法变得有价值了。

声明一个方法是 final 于选择可见性一样。当你不介意别人使用这个方法，但是不允许任何人修改它的时候，声明这个方法是 final 的。当这个方法维护的不变量是复杂而精细的，这种自我保护的可见性是合理地。

为了保证没人会不小心破坏你的对象，当有人打算扩展它时，必须用另外的方式来达到目的。我自己不使用 final，但是在有正当理由去覆写一个方法时，偶尔会碰到 final 方法而感到沮丧。

声明一个方法是 static 来使得即使没有访问这个类的一个实例时都可以访问这个方法。静态方法受限于不能使用对象的状态，所以他不是表示复杂的逻辑的好地方。静态方法可以被继承，但是一旦继承，父类方法就不能再调用到了。静态方法的一个好用法是替代构造器。

### 方法对象

这是我最喜欢的模式，可能是因为我很少使用，但是一旦使用了就会取得较好地结果。创建方法对象可以帮助你将一个方法里面的一大堆代码变得可读，清理代码来慢慢地揭示实现细节。当我有一些可以工作的代码，但是需要更多地复杂的代码时，我会使用这个模式。

要使用方法对象，就找哪些包含很多参数和临时变量的长方法。尝试抽离出方法的某部分会得到一些子方法。这里是一些创建方法对象的步骤（因为自动重构还不支持这种模式）：

1. 在方法后面创建一个类，比如说 complexCalculation() 可以创建一个 ComplexCalculator 类
2. 给每个参数，临时变量和方法里面使用的属性都创建属性。给这些属性命名为使用它原先用到的名字。
3. 创建一个构造器接受原先的方法接受的参数和原先的方法使用的原对象属性。
4. 复制这个方法到新的类里面的新方法 calculate() 。原先方法里面的参数，临时变量，属性会变成新对象里面的属性引用。
5. 在原先的方法体里面调用新对象的方法来代替原先的方法体：

	complexCalculation() {
		new ComplexCalculator().calculate();
	}

6. 如果原先的方法里面会设置一些属性，那就在调用 calculate() 以后设置它们。

	complexCalculation() {
		ComplexCalculator calculator = new ComplexCalculator();
		calculator.calculate();
		mean = calculator.mean;
		variance = calculator.variance;
	}

保证重构后的代码能和之前一样工作。现在，又去的事开始了。新的类里面的代码是很容易重构的。你可以抽离对象然后再也不需要传递参数，因为所有的数据都存储在属性里面。通常，一旦你开始抽离方法，你就会发现很多变量可以从属性降级为临时变量。同样的，有些信息可以通过传参的形式完成而不需要保存为属性。一旦你开始抽离方法，你就会发现原先很难隔离出来的公共表达式可以变成帮助方法并去一个有意义的名字。

有时候，当我想使用方法对象时，发现原先的方法已经被切成小块了。这种情况下，你可以先把所有的子方法内联到一起。一个迹象表明，在你需要使用方法对象之前，你需要多使用内联。退回去，内联化，重新开始。

### 覆写方法

面向对象编程的一大乐趣是你有丰富的办法来表示相似计算之间的差异。覆写方法是一种非常清晰地方式来表达这种多样性。将父类的方法声明为抽象的可以更好地帮助表示需要将某个计算专有化，但是任何没有声明为 final 的方法都提供了一个覆写原先计算的选择。组织良好的父类方法提供了多种潜在的钩子来挂住你的代码。如果父类里面的代码是小而结合紧密的，你可以选择覆写整个方法。

覆写一个方法并不是非此即彼的关系。你可以通过 super.method(); 来调用父类的方法。只有在需要调用父类的同名方法是才这么做。如果你的父类明确地调用自己的代码，有时候好多方法又都调用父类的代码，这样的类会很难追踪，很容易就会不小心破坏。如果你有这种调用不同父类方法的需求，你可能就重新组织你的控制流程，直到不需要再子类和父类之间跳来跳去。

父类变得庞大就会面临一个两难的境地：将父类的代码拷贝到本地然后修改还是寻找另外的方式来表达这种不同？拷贝代码的坏处是之后可能有人来修改了父类的代码，那如果你或者他们不知道就可能破坏你的代码。

### 方法重载

当你使用不同参数来声明一个相同名字的方法时，你就是在说：“这是这个方法的不同版本”。一种情况是，一个方法可以支持字符串来表示方法名或者一个 OutputStream ，这时候就可以提供不同的选择给用户。重载方法减轻了用户转换数据来传递参数的压力。

一个重载的情况是使用相同的方法名不同数量的参数。这种类型的重载的一个问题是读者想知道“这个方法是干什么的？”时，不仅仅不需要知道方法名，还需要知道整个参数列表的含义。如果重载很复杂，那读者就需要非常仔细区分那个方法会被调用。

方法重载都是为了一个目的，适应不同的参数类型。不同的重载方法返回不同的参数使得代码很难读。尝试给新的意图寻找新的名字，给他们取有区分度的名字。

### 方法返回值

方法的返回值会首先告知这个方法是一个处理过程还是返回特定对象的函数。Java 里面返回 void 可以避免通过增加关键字来区分这两种情况。

假定你在写一个函数，挑选一个返回类型来表示你的意图。有时候，你的意图是返回特殊的类型，混合类或者一个原始类型。然而，如果想你的方法能够尽可能广泛地适用，尽量使用抽象的返回类型。这样可以保证你未来可能用到的返回类型。

归纳返回类型也可以帮助你隐藏实现细节。比如说，返回 Collection 而不是 List 可以鼓励用户去假定列表是固定顺序的。

当你升级程序时，返回类型是一个经常变化的地方。刚开始，你可能修改了一个方法的返回值，然后发现其它几个相关方法也要返回不同的关联对象，而每一个又要使用相同的接口。通过声明公共接口然后返回型接口可以帮助读者更好的理解。

### 方法注释

尽可能使用方法名和代码结构来表达信息。仅在注释中添加无法从代码中获取的信息。就像用户需要的， javadoc 中的注释是用来解释方法和类的目的的。

大部分注释是完全多余的。写这些注释和维护它们的正确性的代价远大于其带来的好处。

方法注释是一个尴尬的抽象等级。如果两个方法之间有依赖（一个方法必须在另一个方法调用之后调用），这样的注释应该放在那里呢？注释要和代码分开维护，注释过期并没有合适的反馈方式。

自动化测试能够表达方法注释所能做到的沟通效果。在之前的例子，我可以写一个测试来保证如果方法调用顺序不对会抛出某一个异常（尽管我更喜欢消除或者压缩这种依赖）。自动化测试有很多好处。写测试是一个很有价值的设计实践，特别是在实现之前。如果测试运行了，他们依赖于代码。自动化重构工具可以帮助以极低的代价更新测试。

就像刚刚说的，沟通依赖是这个模式至高无上的价值。如果方法注释是沟通的最好选择，那就写一个好的注释。

### 帮助方法

帮助方法是组合方法的一个推论。如果你想将一个大方法切成很多小方法，你就会用到帮助方法。它们的目的就是通过隐藏临时变量或者使用方法名来表示你的意图来使大块的计算过程更具可读性。帮助方法大多数是私有的，如果需要在子类里面使用，就把它们设置为受保护的。

你可能创建了一个私有的帮助方法，却发现其它人希望直接调用它。如果这个方法在内部有用，那它可能在外部也是有用的。如果你的小帮助方法从来不会毕业，它们还是有很大的沟通价值的。

帮助方法基本上是很小的，但是它们通常可以更短。就在今天，我移除了一个只返回类的构造器的帮助方法。我发现：

	return testClass.getConstructor().newInstance();

和

	return getConstructor().newInstance();

的沟通性是一样的。

但是，如果父类的构造器被覆写了，这样的帮助方法还是挺合适的。

当这个方法的逻辑变得不清晰时，（至少是临时地）清除它们。内联所有的帮助方法，看看这些逻辑，然后抽离出有意义的部分。

帮助方法的目的是消除公共的子表达式。如果你在类中调用一个帮助方法都需要一些计算，那修改这个表达式是很容易的。如果一个对象里面很一行，两行，三行的代码重复，你不仅仅是失去了使用合适的方法名来更好沟通的目的，这样还很难修改。

### 调试打印方法













